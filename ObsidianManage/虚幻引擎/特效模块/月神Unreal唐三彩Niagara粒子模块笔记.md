# Niagata模块讲解

## 第一部分: 基础

### 1.1 Unreal动画重定向与项目动画系统介绍

**1. 插件安装 :**

* KawaiiPhysics: 骨骼物理模拟插件, Github上开源的物理模拟插件.
* PluginDLSS: 英伟达发布的超分辨率采样以及帧生成.

**2. 骨骼重定向 :**

* 新建一个`IK绑定` , 并重新命名. 选择需要被重定向的骨骼模型. 采用骨骼链的方式对骨骼进行重定向.
* 在`IK绑定` , 右下角点击`IK重定向` , 并新增链条. 
* 选择需要被跟随的骨骼, 如头部, 脊柱等, 添加链条. 有以下参考:
  * 脖子关节+ 脖子头部衔接关节+ 头部关节(无五官)
  * 锁骨关节+肩关节+手肘关节+手腕关节;
  * Root单独
  * 每根手指的所有关节
  * 侧豚骨+膝盖骨+脚踝骨+ 脚趾骨
  * 盆骨骨骼右键, 设置为重定向根骨骨骼.
  * 主要躯干, 头发衣服等不必重定向.
  * 每个骨骼链的数量必须要保持一致.
* 注意, 被重定向的骨骼需要和重定向的骨骼名称保持一致性.
* 新建并设置完IK绑定后, 新建IK重定向器, 选择获得动画的骨骼的IK绑定;
* 双击进入, 左侧细节面板中的: 重定向目标, 添加需要被重定向的骨骼网格体, 与相应的IK文件;
* 选择完文件后, 下方映射链会根据名称自动链接相应的IK链; 注意, 要人工检查一遍, 会有概率出错
* 目标网格偏移, 方便观察效果.
* 取消偏移, 检查动画是否完全一致, 如果不一致, 点击左上角, 进入编辑模式.
* 上方选择编辑源, 还是目标. 选择目标. 以下是编辑要求:
  * 模型的大小不影响重定向的质量;
  * 要尽可能保证动画尽可能一致
  * 骨骼要对称修改.
  * 没有太大的穿帮是可以接受的

* 最后, 调整完之后, 选择右下角导出选定动画, 导出需要的动画即可.
* 导出菜单最下面是导出文件名的规则, 可以添加前缀或后缀, 替换或取代.

**3. Animation Blueprint 动画蓝图重定向**

* 原则源动画蓝图, 右键复制和重定向动画资产. IK重定向 选择调整好的重定向文件; 

**4. 人物骨骼解雇的注意事项 :**

* 注意, 人物骨骼的父子级关系需要匹配Unreal的标准骨骼关系. 

---

### 1.2  角色材质

**1. 技巧总结 :**

* 灵活使用自发光可以更好的凸现主体.
* UV采样与噪波图相加可以获得扰乱效果.
* 使用UV偏移获得材质随机效果.

**2. 关于点积运算的两个常用节点 :**

* Fresnel(菲尼尔节点): 159行Shader, 可控制内部颜色.
* Fresnel_Function(菲尼尔计算函数): 153行Shader, 无法控制内部颜色.
* 注意, 本质都是点积运算. 自己连也一样.

**3. 新节点使用指南 :**

* `Desturation` : 降低饱和度节点.
* `WorldAligendTexture`: 直接输入贴图类, TextureSize调整平铺值. WorldPosition 输入UV采样方法,
  * 作用: 忽略模型的UV分布, 直接将贴图按世界坐标XYZ三个轴向, 投射到模型上.

**4. 材质属性个别讲解 :**

* 搜索`Fog` 有对雾影响的选项. 会增加很多Shader, 在使用半透明. 叠加模式, 调整模式时可以关掉.
* 材质的混合模式: 不透明; 透明遮罩; 半透明等模式.

**5. 设计方法 :**

* 避免单调的颜色搭配可以避免低级感.
* 灵活使用 点 线 面 的元素搭配, 丰富物体的完整度.
* 在动态材质中, 可以使用扰乱等技巧丰富材质表现力.
* 在使用材质父系穿件材质实例时, 要谨记注意, 不要有雷同动态材质, 使用UV偏移或其他方法让各物体的纹理具有随机性. 也就是避免雷同. 

---

### 1.3 Niagara 基础操作及其实现原理

**1. 基础图形界面讲解 :**

**前置基础 :**

1) 场景中播放粒子的方法:
   1) 选择场景中的Niagara, 按问号键
   2) 在Niagara界面中按空格播放.
2) 如果调整参数时没有变化, 这是常见的Bug.
   1) 重新启用属性即可.
   2) 删除发射器, 重新创建即可.

**一. Niagara系统节点 :**

* 选项面板:
  * `Wamup` 暖场:
    * `Wamup Time`: 设置预热值. 单位秒, 在播放粒子时, 直接播放本粒子相应秒数时的状态, 场景特效等常用

**一. BlowingParticles发射器 :** 

* 以`BlowingParticles` 发射器距离:
  * `ProPerties` (属性): 
    * 调整粒子发射器的基本属性. 
    *  `Local Space`: 生成的粒子是否跟随原点移动. 输入布尔值.
    * `Sim Target`: 粒子的计算方法, 为枚举型.
      * GPU: 不建议平常使用, 适合运算巨量粒子. 如雨雪吗花瓣等.
      * CPU: 常用.
    * `Fixed Bounds`: 固定边界, 调整渲染剔除范围. 
      * Fixed: 静态边框, 摄像机只要转出设定边框就会被剔除渲染.
      * Dynamic: 动态边框, 摄像机内只要存在粒子即不会被剔除. GPU模式不推荐使用.
  * `EmitterSpawn` (发射器生成) : 
    * 意义: 类似构造函数, 发射器在生成时执行的指令.
  * `EmitterUpdate` (发射器更新) :
    * 发射器再运行的过程中所执行的操作. 在此阶段确定粒子发射器是循环发射还是一次性发射. 以及发射器持续的时间, 粒子的数量等.
    * SpawnRate(发射器速率):
      * SpawnRate: 输入数值, 调整发射器发射粒子的速率. 速率越快, 发射的频率越快. 
  * `ParticleSpawn`(粒子生成) :
    * 粒子生成时执行的程序. 在此期间确定粒子的生命值, 大小, 颜色, 旋转朝向, 生成时的位置, 粒子加速度等.
  * `ParticleUpdate` (粒子每一帧执行的程序) :
    * 大小随生命值的增加发生的变化, 颜色发生的变化, 速度, 位置发生的改变等. 如重力, 风力, 空气阻力, 碰撞等.
  * `Render`(粒子渲染器): 
    * 定义粒子是哪类, 如精灵粒子, 模型, 灯管, 石头, 火焰等. 此流程可以使用材质系统.
* 程序的运行过程是重上到下. 

**二. SimpleSpriteBurst发射器 :**

* `Emitter Update` (发射器更新)
  * `Life Cycte Mode` : 设置循环模式, 输入枚举型: `Self` `System` 
    * System: 循环模式继承自系统
    * Self: 循环模式使用自身设定.
  * `Inactive Response` (粒子在失活后的反应)
  * `Loop Behavior` (自身循环模式): 设置节点自身的循环模式. 输入枚举型.
    * Once: 一次性发射
    * Multiple: 限定次数的发射
    * Infinite: 无限次发射(在使用Infinite时, 我们喜欢吧Spawn Burst Instantaneous 更改为 Spawn Rate)
      * Spawn Rate
        * SpawnRate: 每秒发射多少粒子.
  * `Loop Duration`: 每次发射持续的时间. 单位s
  * `Loop Delay`: 每次发射前延迟.
    * `Delay First Loop Only`: 仅第一次发射有延迟.
* `Particle Spawn` 粒子生成
  * Initialize Particle
    * Lifetime: 粒子存活时间
    * Color: 强度, 颜色
    * Sprite Size Mode: 粒子大小模式, 输入枚举型
      * Uniform: 统一大小
      * Random Uniform: 随机大小
      * Non Uniform: 不统一大小
    * Uniform Sprite Size: 粒子大小
* `Particle updata` 粒子更新
  * Scake Color: 曲线调整粒子透明度.
    * Curvelndex: 曲线指数, 
      * NormalizedAge: 百分比指数, 生命值归一.
      * Age: 手动输入粒子生命
      * LoopedAge: 发射器生命周期, 连接到发射器更新的属性里.

## 第二部分: 普攻第一部分

### 2.1 使用BluePrint实现物体在三维空间中的贝塞尔曲线路径运动

**1. 贝塞尔算法 :**

* 核心为线性插值,  当有向量A 与浮点型Lerp = [0, 1],  则输出 A的模乘以 Lerp. 数学意义为 y = lerp * x.(lerp = [0,1]);
* 一阶贝塞尔输出直线
* 二阶贝塞尔曲线为三个点中两两插值, 得到两个点形成的线段, 再在这个线段上线性插值. 也就是无论几阶的贝塞尔,最后都是一阶贝塞尔.

> 四阶贝塞尔曲线:
>
> * 已知四阶贝塞尔曲线有四个顶点.
> * 分别求三段线的线性插值, 求出三个顶点化成的贝塞尔
> * 三个顶点化为两段线, 依次计算
> * 得出最终结果
> * Lerp输入Time, 可以同时输出一个结果.

**2. 蓝图算法扩展 :**

> 使用递归数据结构
>
> 完成任意梯度的贝塞尔曲线运动
>
```c++
> //递归算法演示
> void test01(int* P) {
> 	if (*P >= 666) return;
> 
> 	*P += 1;
> 	cout << *P << endl;
> 
> 	test01(P);	//在函数内存释放之前, 已经创建了新的形式参数.
> }
> int main() {
> 	int a = 0;
> 	int* T = &a;
> 	test01(T);
> 	
> 	return 0;
> }
> //注意, 递归层级不要过高, 否则会导致栈区占用过高.
> //VS测试栈区最大调用为3000+
> ```

**基本逻辑 :**

**1. 贝塞尔算法实现逻辑 :**

```c++
vector BezierMove(vector LocationArray[], float Lerp){
    //递归条件,如果贝塞尔只剩一个点, 也就是此数组只剩一个元素, 则停止递归
    if (LENGTH(LocationArray) <= 1){
        //第三层,也就是最底层递归返回给第二层递归. 如果不写第18行代码, 则第二层递归不会返回值, 则顶层递归不会接受底层递归返回的值. 
        return LocationArray[0];	
    }
    //声明形式参数容器, 储存计算结果
    Vector LocalLocationArray;
    //for循环, 循环的次数小于等于点的总数减二
    for(int Temp = 0; Temp <= (LENGTH(LocationArray) - 2); Temp++){
        //初始化形式参数, 储存Lerp计算的结果.
       LocalLocationArray.ADD =Lerp(LocationArray[Temp], LocationArray[Temp++], Lerp);      
    }
    //循环之后引用本函数, 形成递归
    BezierMove(LocationArray[], Lerp);
    
    //接受底层递归返回的结果.
    return  BezierMove(LocationArray[], Lerp);
}
```

**2. 路径计算逻辑 :**

```c++
//创建路径计算函数, 参数列表为运动至的目标位置.功能: 计算函数路径, 设置蓝图位置.
void Beziertlocation(vercor){
    //请补充BP基础后再次补充.
}
```



### 2.2 宝石的粒子系统

**1. 工作须知 :**

































