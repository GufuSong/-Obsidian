> Unreal Engine 材质渲染模块笔记 ,  作者松谷福 ,  QQ :  2148103921 .  反馈错误联系我 ,  好人被从天而降的金砖砸晕 .


# Ⅰ. Material 可视化节点


 ## 第一部分: 前置知识

### 1.1 `Time` `Debug` 时间调试节点.

**`Time`**

* 输出引擎运行时间, 经常搭配`Frac` 取小数节点使用.

**`debug`**

* 调试节点, 输出运算的具体数值.

---

### 1.2 材质与材质实例

**解释 :**

* 在底层里面, 每一个节点都是封装好的HLSL代码. 
* 材质实例为: 参数化的材质, 在Unreal, 可以通过仅修改变量参数 , 直接控制效果.

---

### 1.3  编译阶段静态开关

**1.`staticswitchparameter`流程结构静态开关**

* 该节点不输入布尔值, 布尔值为自身成员属性. 若为true, 则输出true接口连接内容; 若为flase, 则输出连接flase接口的程序
* 使用该开关会生成多套HLSL代码, 然后进行切换.
* 该节点为编译阶段展开, 无法再运行中临时切换.

**2.`ChannelMaskParameter`通道遮罩静态开关**

- 编译阶段控制矢量的通道选择 .

---

### 1.4 `Custom` HLSL编程节点

* 直接编写HLSL, 本质为声明函数 .

>使用快捷键`ctrl`+`Shift`+`,`可以调出虚幻引擎的渲染管线渲染顺序 .

### 1.5 材质着色基础

**一. Material Blend Mode :**

- **`Opaque`不透明的**
	* 常用的RPG不透明模式

- **`Masked`透明与不透明**
	* 只有透明与不透明 .

- **`Translucent`变暗的半透明**
	* 不叠加背景的半透明模式 ,  不会变亮

- **`Additive`变亮的半透明**
	* 叠加背景的半透明模式 ,  更亮 ,  但暗部细节少 .  注意 ,  当Opacity = 0 时 ,  材质的自发光当然会叠加背景的颜色 ,  因此 ,  不会有Translucent的完全消失的效果 .  类似遮罩或染色的效果 .  常用于彩色玻璃等 .

- **`Modulate`混合调节**
	- 改`Blend Mode`仅支持uint模式 ,  仅有Emissive Color 与 World Position Offset 两通道 .  运算方法为屏幕像素显示为 :  材质颜色乘以背景颜色 .  
- **`AlphaComposite`根据透明度决定是否叠加背景**
	- 根据透明度的大小进行平衡的半透明模式 .  算法细节为 :  Alpha 为 0 的部分为Add模式 ,  Alpha 为 1 的部分为Translucent模式 .

**二. Shading Model 光照模型**

- Unlit 无光照
- Default Lit 正常光照

**三. 材质作用域 :**

- `Surface` 表面着色
- `Post Process` 后处理着色


**三. Material基础选项 :**

- `Two Sided` 双面着色
- `Use Material Attributes` 使用材质选项 (使用`SetMaterialAttributes` , `GetMaterialAttributes`节点使用)
- `Alllow Negative Emissive Color` 准许自发光发射负颜色
- `Decal Response(DBuffer)`: 贴花相应模式 .


**四. Translucency 半透明选项 :**
- `Responsive AA` 半透明材质是否启用抗锯齿 .
- `Lighting Mode` 光照模型 .
	- `Volumrtric NonDirectional` 
	- `Volumrtric Directional` 注意, 只有你启用了Directional, 才能启用法线 .
	- `Volumrtric PerVertex NonDirectional` 
	- `Volumrtric PerVertex Directional` 
	- `Suface TranslucencyVolume` 
	- `Suface ForwardShading` 性能效果最高 ,  并且效果最写实的渲染模式 .

>半透明材质在光照上具有缺陷 ,  如 :  亮度异常 ,  光照纹呈现方格图形 , 闪烁 ,  等 .  优化办法如下 ;
>1. 使用命令行参数调整光照体积细分次数 : `r.TranslucencyLightingVolumeDim m`m为数字(默认64) ,  但使用此命令行会导致显存需求增加 ,  不建议任意更改 .

**五. Material Types :**

- `Base Color`: 反射率属性
- `Normal` :  法线属性
>半透明物体想使用法线属性需要在半透明光照模型中使用Driectional.


- `Roughness` :  粗糙度属性 
>在非光线追踪情况下, UE计算反射是烘焙的反射球 + 屏幕空间反射SSR .  所以并不准确 .  因此物体反射在材质预览窗口里与场景里效果不同是常有的情况 .  
>在没有使用`Sphere Reflection Capture`反射球的情况下 ,  物体反射只会反射出屏幕空间出现的物体 .  而反射球可以帮助我们捕捉范围内的物体 ,  并烘焙一张低分辨率的贴图 .  令屏幕空间外的像素也能产生一些被反射的效果 .

- `Refraction` :  折射
	- 物理上, 折射控制光线在非垂直角度下(模型法线需要与摄影机形成一定夹角)穿过物体表面所发生的扭曲程度 .  默认值为 1 ,  值小于 1  为放大镜效果 ,  值大于1 为缩小镜效果 .  注意 ,  折射是根据屏幕空间计算的 ,  也就是无法渲染屏幕之外的物体 .  
	- **注意:** 自发光材质不受折射影响 .  除非将`Material`的`Render After DOF`取消勾选 ,  将其在景深前渲染 .
	- 本属性常与Lerp节点配合运用 .  


### 1.6 GPU架构与渲染管线优化

**一. GPU硬件架构基础 :**

**1. NVIDIA GPU 架构梗概 :**

- 从 Fermi 架构开始 ,  NIVIDIA开始使用类似的原理架构 .
	- GPU 包含若干个 GPC (Graphics Processing Cluster ,  图形处理簇)
	- GPC 包含若干个 SM (Stream Multiprocessor ,  流多处理器)

>Maxwell 的一个GPC 有4个SM
>Turing的一个GPC 包含了 6 个TPC (texture / Processor Cluster ,  纹理处理簇 ) ,  每个TPC 又包含了两个SM .

**2. SM - Shader Model  着色器语言处理单元**

- SM 存在于 GPC 内 ,  为 SM 提供并行处理的架构 .  SM 全名为 Stream Multiprocessor ,  流多处理器 

- SM 处理单元内包含以下功能 :
	- PolyMorph Engine 多边形变形引擎 ,  处理多边形与顶点的工作 .  
		- Vertex Fetch :  处理三角面的索引 ,  取出三角形数据 .
		- Tessellator :  DX11 引用 ,  处理曲面细分 .
		- Vlewport Transform :  处理顶点的视图变换 ,  三角形会被处理成像素
		- Attribute Setup :  负责顶点的插值运算 .  将每一个三角形渲染在屏幕上形成的像素点处理出来 
		- Stream Output :  处理渲染完之后的图形输出 .
	- Core :  处理各种各样的渲染指令 .  图形渲染运算核心 .  处理单一渲染流程 .  简称SP (Stream Processor)
	- Warp Scheduler :  调度Core核心 .
	- Instruction Cache :  输入Shader指令
	- SFU :  处理高阶数学运算 .  指令开销比较昂贵 .
	- LD / ST :  临时储存数据 .
	- Register File(32768 * 32 bit) :  一级缓存 ,  寄存Core运算时产生的数据 .  速度快 ,  容量小
	- Shared Memory (64kb) :  二级缓存 ,  访问速度慢一些 ,  容量更大 
	- Uniform Cache :  全局统一缓存
	- Tex Unit 和 Texture Cache:  纹理缓存 ,  Fermi架构为 4 个Tex采样器 ,  每个单元内部有4个通道 .能够采样16个纹理 .
	- Interconnect Network :  核心之间用来交换数据 .

 ![[DCE12CEEAAC04A47B3303D04ADD11985.png]]

**3. GPU内存分布 :**

![[0250131225128.png]]

>访问周期越快 ,  内存容量越慢 .  反之 ,  反之 .

|         | Shader Model 2.0 / 2.x | Shader Model 3.0 | Shader Model 4.0 |
| ------- | ---------------------- | ---------------- | ---------------- |
| 临时寄存器   | <= 12                  | 32               | 4096             |
| VS常量寄存器 | <= 256                 | <= 256           | 14*4096          |
| PS常量寄存器 | 32                     | 224              | 14*4096          |
| VS纹理    | None                   | 4                | 128*512          |
| PS纹理    | 16                     | 16               | 128*512          |
| VS输入寄存器 | 16                     | 16               | 16               |
| 插值寄存器   | 8                      | 10               | 16 / 32          |
| PS输出寄存器 | 4                      | 4                | 8                |

**4. Shader Modle 处理 API 的具体流程 :**

- 写好的 shade 被储存到指令缓存(Instruction Cache)里 .
- Warp Scheduler 将shader分配到Core里 ;  Shader 里的变量存储至 Register Files 里 .
- 因为一个Shader Modle 有 32 个Core核心 ,  因此一次可以同时运行 32 组Shader指令 .  如32个顶点 ,  32 个 像素 ,  32 个三角面 .

>统一着色器架构 :
>	假设一个摄影机面前有一个由100个点构成的小球 ,  由于距离近 ,  则在显示器上占用1000个像素 ,  计算压力被分配至像素计算上 ;  同样的小球 ,  但由于距离远 ,  仅占用10个像素 ,  计算压力配分配至顶点计算上 .  此时 ,  为了解决这样的消耗问题 ,  英伟达工程师发明了Core核心 .
>	在顶点计算阶段 ,  可以算顶点 .  像素计算阶段 ,  可以算像素 .

>SIMT 单指令多线程
>	对于A运算核心来说，tmp25号存了“2”，tmp26号存了“3”，最终计算后写入tmp27号寄存器的数是"5”对于B运算核心来说，tmp25号存了，tmp26号存了“12”，最终"8"计算后写入tmp27号寄存器的数是“20”
>	总而言之 ,  相同的指令 ,  由于相同地址的指针指向的内存区的数据不同 ,  Core 计算得出的结果是不一样的 .

>Warp 线程束
>	一个SM上总共也就32个运算核心 ,  但是如果多余32个线程需要执行怎么办 ?   (假设128个线程 )Warp 会把线程数除以 32 ,  获得4组线程 .  当运算复杂线程时 ,  运算第二组线程 ,  当第二组运算到复杂进程时 ,  则再运算第三组 .  直至第一组的复杂线程运算完 ,  则继续运行复杂线程之后的其他线程 .  
>	总结为通过线程束 ,  不让任何一个Core核心闲下来 .

**二. Unreal 渲染管线:**

**1. 透明与不透明 :**

- 虚幻引擎的渲染管线先绘制不透明物体(Opaque, Masked) ,  再绘制半透明物体 .  而半透明物体的渲染分两类 :  `STranslicent` 和 `Translicent` ,  虚幻会先渲染`Translicent` ,  再渲染 `STranslicent` .  在默认情况下 ,  虚幻会将属性`Render After DOF`勾选 ,  也就是所有的半透明都默认在`STranslicent`的模式下被渲染 .  但是 ,  如景深 ,  折射等操作都在`STranslicent`前进行绘制 ,  也就是`STranslicent`不会受景深 ,  折射等效果影响 .  除非取消勾选`Render After DOF`.
### 1.7 Curve工具

**1. Curve的概念 :**

- X轴为0-1 ,  y轴输出自定义颜色 .  
- 虚幻自带Curve工具 ,  使用 Curve Atlas 可以对Curve进行烘焙 .
- 烘焙的贴图在材质系统中使用 `CurveAtlasRowParameter`进行使用 .

>每帧赋值会造成较大消耗 .
### 1.8 顶点着色器

**1.`WPO World Position Offset`世界位置偏移**

>使用须知 :
>	此接口的算法为加法 ,  顶点本身位置 + 输入的数值 .

- 使用顶点着色器实现 ,  脱离CPU运算的 ,  在GPU渲染时进行顶点偏移渲染的功能 .  注意 ,  仅影响视觉效果 .
- 在顶点着色时运算 .  因此 ,  顶点偏移会影响像素的位置 .

### 1.9 Normal Texture

**一. Normal 的基本概念 :**

- 程序意义 :
	- Normal 的基本颜色为 `[0.5, 0.5, 1]` ,  此 0.5 的意思是中值 ,  0 的意思 ,  高于0.5的部分视为`[0, 1]` 低于0.5的部分视为`[-1, 0]` .
	 - 法线贴图可以改变像素的法向 ,  也说明可以直接改变像素的光照反射方向 .
	 - 注意 ,  R通道代表右侧打光强度 ,  G通道代表下侧.

### 1.10 空间坐标系

**一. 切线空间 :**

- 切线空间是一个坐标空间，由顶点所构成的平面的 UV 坐标轴以及表面的法线所构成，一般用 T (Tangent), B (Bitangent), N (Normal) 三个字母表示，即 切线，副切线，法线。在切线空间中，坐标原点就是顶点的位置，一个坐标轴是该顶点本身的法线方向（N），另外两个坐标轴就是和该点相切的两条切线。切线空间在法线贴图中有着重要作用，通常需要把灯光转换到切线空间进行计算。

### 1.11 Decal 纹理投射工具

**一. 创建Decal Material :**

**1. 注意 :**

- `Decal`只支持`Deferred Decal`材质作用域 , 并需要将`Blend Mode` 更改为:`Translucent`
- 当使用此模式时 ,  可自定义Decal Blend Mode .  并选择需要影响的材质接口 .
- `Decal`可以将网格体做为载体 .  在网格体投射在屏幕的范围内 ,  深度大于网格体的像素将会被`Decal`影响 .

>在游戏制作中 ,  Decal 在地形编辑上使用的较多 .  在一定程度上较为节省性能 .


**二. Decal 的 Details( 参数 ) :**

**1. Decal Fade :**

- `Fade Start Delay` :  从此 `Deca` 生成时 , 到进入前所需时间 .
- `Fade in Duration` :  开始运行后 ,  进入时所需的时间 .
- `Fade Duration` :  总生命时间  .  注意 ,  与`Fade in Duration`有一定耦合性 .
- `Fade in Start Delay` :  延迟运行时间 ,  单位s .

> 这些值默认为 1 ,  如果输入0 ,  也会按照1 计算 .

**2. 用法套路 :**

- 由于这几个变量之间过于耦合 ,  在使用时 ,  我们只会使用`Fade Start Delay`与`Fade in Duration` ,  这样`Material`的接口`Decal LifeTime Opacity` 可以线性输出 0 - 输入值 ;  搭配Curve 即可完整使用 .


**三. Decal 的 Material 接口 :**

**1. `Decal LifeTime Opacity` 

- 作用 :
	- 输出`[0,1]`值域的常数 ,  根据`Fade in Duration`输出进入时的单位时间 ,  再根据`Fade Duration`输出死亡时的单位时间 .


**四. Decal 的BluePrint 接口 :**

**1. `Add Decal Component`添加Decal**

### 1.12 材质与BluePrint的交互

**一. 动态材质实例交互 :**

**1. `Create Dynamic Material Instance`创建动态材质实例**

- 作用 :
	- 可以搜索虚幻内的Material 并创建相应的材质实例 .
- 参数列表 :
	- Parent :  输入材质名 ( 一个字母都不能错 ) .

**2. `Set Vector Parameter Value`设置矢量参数

### 1.13 视差贴图

**一. 视差贴图的制作思路 :**

**1. 必要的纹理 :**

- 自发光贴图 :  更好的控制纹理细节 .
- 反射率贴图 :  控制基本都底色 .
- 深度贴图 :  调整像素偏移的量 .

>使用 SD 混合制作 .


### 1.14 `ExponentialHeightFog`指数级高度雾


**一. Detail :**

**1. `Volumetric Fog` 体积雾**

- `Albedo` :  反射率 ,  输入雾的固有色 .
- `Emissive` :  自发光 .  通常不使用 .
- `Extinction Scale` :  体积雾浓度调整 .
- `View Distance` :  体积雾影响距离 .  在GPU Visualizer中 ,  可以查看体素的渲染距离 .

**二. `ExponentialHeightFog Material`**

**1. 使用须知 :**

- 需要将 `Material Domain` 更改为 `Volume` .
- 需要将 `Blend Mode` 更改为 `Additive` .
- 当此材质被赋予至静态网格体上使用时 ,  默认调用该物体的 AABB包围盒范围 .  

>此材质是三维信息材质 ,  输出体素的信息 .


**2. 模式参数 :**

- `Albedo` :  基础色 .
- `Emissive Color` :  自发光颜色 .
- `Extinction` :  浓度 ,  输入常量 .  但无法超过物体AABB包围盒的边界 .
- `Ambient occlusion` :  环境光遮蔽 .

>体积雾本身不会造成巨大的性能消耗 ,  但灯光打在体积雾上会造成较大的性能消耗 .
### 1.15 RenderTexture2D 渲染纹理2D

**一. 基础介绍Render Texture 2D :**

**1. 基础功能 :**

- 将场景里的指定区域渲染在一张图上 .
- 实时记录一些信息 .

**2. 什么是Render Texture :**

- 本质为纹理对象 ,  但是可以通过程序编辑纹理 .
- 打破的静态纹理的限制 .

**3. 使用场景 :**

- 使用 `Scene Capture Component 2D` 组件进行实时绘制 .
- 记录图形信息 .

**二. Details说明 :**

- `Texture Render Target 2D`
	- `Size X` :  x 轴分辨率 .
	- `Size Y` :  y 轴分辨率 .
## 第二部分: 纹理 ,  纹理采样以及UV

### 2.1 `TextureCoordinate` `TestureObject` 纹理, 纹理采样, UV坐标

* 纹理需要被被纹理采样器采样之后才可以使用

**`TextureCoordinate`**

* 纹理坐标: 决定了如何对纹理进行采样, **一次性用贴图的方式输出每一个纹素的纹理坐标 ** *[比如最中间的纹素, 就输出相应的纹理坐标, 左上角的纹素, 也输出相应的纹理坐标.而这个坐标由属性调控; 纹理锁表有一个成员属性, 就是自身的坐标系, ]* 数学意义为二维矢量, 默认情况下, 取值范围为[0,1] ; 注意, 在Unreal里, 纹理坐标的原点为左上角.

* 具体输出位一张贴图, 是由两张贴图构成:

  * ```u
    01234
    01234
    01234
    01234
    01234
    ```

  * ```v
    0000
    1111
    2222
    3333
    4444
    ```

* 属性面板:
  * 坐标索引: 控制使用不同的UV集;

> 纹理对象在使用时 ,  可以更改表面纹素在二维矢量中的排列顺序 ,  这个过程叫纹理采样 ,  讲过采样后的纹理才能根据模型的顶点UV信息获取相应像素的Color矢量信息 .

**`TestureObject`**

* 输入一个纹理对象
* 右键可转换为纹理采样器

---

### 2.2 使用纹理采样案例:

| 操作                                   | 现象                                                         | 解释                                                         |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 将输出的二维矢量的分量做==加法或减法== | ==平移==, 方向由数值的正负性决定, 距离由数值的绝对值决定, 轴向由被运算的分量决定 | 由于UV坐标输出的为每个UV空间中每个纹素对应的坐标在纹理空间中的坐标, 因此将结果运算即为对整个UV纹理空间进行运算. 也就是整体偏移. 也可以使用`Panner` 节点 |
| ==扩大UV平铺至2倍并平移半个单位==      | 缩小1倍                                                      | 将采样模式改为限制, 图形显示在左上角, 右移并下移半个单位, 即缩小一倍. |
| ==扩大UV并平移即可产生选取采样的效果== | 选取采样                                                     | 根据纹理缩放并相应平移, 即可完成选取采样的效果. 可以搭配HLSL, 编写更清楚的逻辑 |
|                                        |                                                              |                                                              |

**`Panner`平移运动节点**

* 平移运动节点
* time 输出时间, 乘法可以控制速度
* Speed 可以控制速度和时间, 可以直接输入三维矢量

**`ScaleUVCenter`UV缩放**

* 输入UV坐标, 在`TextureScale` 输入缩放倍率, 即可输出被缩放过的纹理UV

**`Rotator`UV旋转**

* Unreal 自带的UV旋转节点.可以令UV原地旋转. 可以输入时间并搭配乘法控制速度. `Coordinate` 输入UV坐标.
* 属性列表 `CenterXY` 输入旋转圆心的位置;

**`VectorToRadialValue`极坐标**  

* 输出两个维度的贴图: R通道: 以圆心为中点, 区分了四个向量. 注意, 向量之间是过渡的.

  * | 0.66  | 0.83    | 1       |
    | ----- | ------- | ------- |
    | 0.495 | 原点(R) | 0       |
    | 0.33  | 0.165   | 0-0.165 |

  * | 1    | 1    | 1    | 1    | 1    |
    | ---- | ---- | ---- | ---- | ---- |
    | 1    | 0.5  | 0.5  | 0.5  | 1    |
    | 1    | 0.5  | 0(G) | 0.5  | 1    |
    | 1    | 0.5  | 0.5  | 0.5  | 1    |
    | 1    | 1    | 1    | 1    | 1    |

  * RG两通道分别输出以上数据.搭配Sin相加可以获得旋转消失的效果.

> 套路1) 使用UV采样, 直接将UV采样加上噪波贴图, 可以出现扭曲的效果. 
>
> * 原理为: UV采样输出一张二维贴图, 将二维贴图与噪波贴图相加(注意, 相加前使用Mask 分离出两个通道) 可以令相应位置的纹素信息发生改变, 从而达到扭曲效果.



### 2.3 Date输入

#### 2.3.1 `Scene Color`读取屏幕颜色

**`Scene Color`读取屏幕颜色**

* 作用 :  它准许材质访问场景渲染在屏幕上的最终颜色 (包括光照 ,  后期处理效果等 .) 
* 行为 :  实时变换模型的纹理 ,  就像透明一样 .
* 参数列表 :  UVs ,  输入UV的纹理采样 .  

**一. 方法扩展 :**

* 本节点常用于半透明扭曲 ,  像素化等 .

#### 2.3.2 `Particle Color`粒子颜色

* 作用 :  读取粒子的颜色属性 .


#### 2.3.3`Dynamic Parameter`输入粒子属性

* 作用 :  将粒子属性输入至Shader

#### 2.3.4 `Vertex Color` 输入顶点颜色

- 作用 :
	- 输入顶点信息中的Color ,  常用于积水等 .


#### 2.3.5`Particle SubUV`粒子Sub UV

- 作用 :
	- 搭配Sub UV使用 .

#### 2.3.6 `Particle SubUV Properties`粒子SubUV属性

- 作用 :
	- 输出采样器所需要的UV纹理坐标 ,  用于将Sub UV的序列帧逐帧单独采样输出 .  Blend输出混合强度 .


#### 2.3.7 `AtmosphericLight Color/Vector`大气光照颜色

**一. Color作用 :**

- 输出大气光照的颜色 ,  可以与Level实时链接 .  当出现两个以上的环境光时 ,  会出现问题 .

**二. Vector方向 :**

- 输出大气的光照方向 .

---

## 第三部分: 数学函数

### 3.1 四则运算 (Add,Mul,Sub,Div)

**`Add`加法**

* 参数列表
  * 输入需要相加的两个元素.



**`Multiply`乘法**

* 图形意义
  * 正片叠底.
  * 任何数乘以0 等于 0, 因此乘法可以调整灰部的亮度

* 参数列表
  * 输入需要相加的两个元素.



**`Subtract`减法**

* 参数列表
  * 输入需要相减的两个元素.



**`Divide`除法**

* 参数列表
  * 输入需要相除的两个元素.

>请注意 ,  在一般代码编写中 ,  乘除多为混色运算 ,  加减多为逻辑运算 .

**1. 使用须知 :**

* 计算机再进行除法运算时需要消耗更多的机能.
* 基础计算的组合可以做出很多的效果. 不要小看.



**一. 算法扩展 :**

* 将灰色区域变暗并增加黑色区域 :
  * 乘以2; 减去1: 灰部小于0.5的部分 变为黑色; 大于0.5的部分变暗, 等于1的部分不变.




### 3.2 分离与构成矢量 (Mask,Append)

**1.`Mask`分离分量**

* 作用 :  分离矢量的分量



**2.`Append` 构成矢量**

* 作用 :  将矢量或实数构成新矢量

> 矢量的顺序有左边的接口的先后顺序决定．



### 3.3 取整 (Floor,Ceil,Round,Truncate)

**1.`Floor`向下取整**

* 只要存在小数 ,  则整数部分加一并去除小数 .



**2.`Ceil`向上取整**

* 只要存在小数 ,  则整数部分减一并去除小数 .



**3.`Round`四舍五入**

* 数学层面的四舍五入



**4.`Truncate`抛弃小数**

* 抛弃小数部分 



**一. 算法扩展 :**

* 色块像素风格算法 

  * 将纹理乘以int A ( // 将纹理的数学色阶提高五倍 ) ,  A决定像素的密度 .  使用取整数学函数处理 ,  并除以 int A ( // 将纹理的色阶降低至可视色阶 ) .

  ```c++
  int A; //A决定像素的密度
  return Floor(Texture * A) / A; //floor可以是任意取整函数 .
  ```



### 3.4 取余与取小数 (Fmod,Frac)

**1.`Fmod`取余**

* 被除数最大限度除以除数后所剩的余数 .



**2.`Frac`取小数**

* 取浮点型小数点后面的数 .

**一. 算法扩展 :**

* 灰阶算法 :
  * 将[0 ,  1] 的图像取余一个 float A (A < 1) ; A 决定灰阶的个数 (灰阶个数 =1 / A) ; 
* 亮阶算法 :
  * 将[0 ,  1] 乘以 int A 后进行 Frac 取小数即可 .  int A 决定亮阶的个数



### 3.5 线性插值 (Lerp) 

**1.`Lerp`线性插值**

* 线性插值 原理为 :  `(A * (1 - C)) + (B * C)`
* 参数列表 :  A , B , Alpha .  当AB输入矢量时 ,  Alpha可以输入矢量(参数分量分别进行Lerp运算) ,  也可以输入常量(使用常量分别进行Lerp运算 .)

> 注意 ,  线性插值Alpha输入的值如果大于1则会出现错误的效果 



**一. 算法扩展 :**

* 动态变色
  * 使用变换的Alpha可以实现自动变色的效果 .



### 3.6 绝对值 (Abs)

**1.`Abs`绝对值**

* 对输入的数取绝对值 .



### 3.7 反向 (1-x)

**1.`1 - x`反向**

* 取一维坐标系相反的数 .  



### 3.8 钳制 (Clamp,Saturate)

**1.`Clamp`软件钳制**

* 可以将输入的值钳制在任意的范围里



**2.`Saturate`硬件钳制**

* 只能钳制在0-1之间 ,  基本0消耗 .



**一. 算法扩展 :**

* 动态消散
  * 使用Time节点 ,  钳制最大值 ,  配合线性插值可以实现材质动态渐变 



### 3.9 三角函数 (Sine ,  Cosine)

**1.`Sine()`余弦**

* 输入 X 轴 ,  输出 Y 轴



**2.`Cosine()`正弦**

* 输入 X 轴 ,  输出 Y 轴



**一. 算法扩展 :**

* 动态变量
  * 可以输入Time ,  绝对值之后获得 0-1 变换的变量 .

### 3.10 取最大或最小 (Max,Min)

**1.`Max`取最大**

* 输入两个参数 , 对比每个参数 ,  输出新的由最大的构成的数据 .



**2.`Min`取最小**

* 输入两个参数 , 对比每个参数 ,  输出新的由最小的构成的数据 .



**一. 算法扩展 :**

* 亮部替换
  * 使用Min 可以直接替换亮部 .



###  3.11 取符号(Sing)

**1.`Sing`取符号**

* 大于 0 返回 1 , 小于 0 返回 -1 , 等于 0 返回 0.



### 3.12 判断输出 (if)

**1.`if`判断输出**

* 输入变量 A B ,  如果 A > B 输出相应接口 ,  如果 A = B 输出相应接口 ,  如果 A < B 输出相应接口 .



**一. 算法扩展 :**

* 动态消融与扩散
  * 使用[0-1] 的动态变量对纹理进行if 判断 ,  可以获得动态消散与扩散效果 .

### 3.13 幂次方 (Power)

**1.`Power`计算次方**

* Base 的 Exp 次方 
* 图形效果为两极化灰部 ,  大的更大 ,  小的更小 .

>在实际运算中 ,  Power 的底数如果输入小于0的数 ,  则返回 0 .

**一. 算法扩展 :**

* 动态灰部
  * 使用动态变量的幂次方控制Alpha贴图的灰部 ,  实现动态灰部的效果 .



### 3.14 点乘 (DotProduct)

**1.`Dot`点乘**

* 输入矢量进行点乘运算 .
* 图形效果为两向量夹角 :  大于90° 返回 负数 ,  等于90° 返回零 ,  小于90° 返回正数 .

**一. 算法扩展 :**

* 菲尼尔效果
  * 菲尼尔效果的核心算法 .  


### 3.15 `Transform`变换坐标系

- 作用 :
	- 不同坐标系间转换坐标系 .


### 3.16 `Distance`距离

- 作用 :
	- 输入两个矢量 ,  得到距离

### 3.17 `Desaturation`去饱和度

- 作用 :
	- 输入三位矢量 ,  进行去饱和度算法 .

### 3.18`ConstantBiasScale`偏移并缩放

- 作用 :
	- 将输入的数据偏移并缩放 ,  数学公式为$(x + Bias) * Scale$ , x为输入值 .
## 第四部分: 方向输出函数

### 4.1 `Camera Vector` 相机向量

- 作用 :
	- 输出像素指向相机原点的方向

- 用法 :
	- 可以采样HDR三维信息贴图 ,  获得随视角转动进行动态变化的效果 .


### 4.2 `Reflection Vector` 反射向量

- 作用
	- 输出像素法线与相机法线反射运算后的向量 .  输出矢量与`Camera Vector`的X , Y 矢量为相反数 .


### 4.3 `VertexNormalWS`顶点法线

- 作用
	- 输出顶点的法线方向 .


### 4.4 `PixelNormal`像素法线

- 作用 :
	- 输出像素的法向 .


## 第五部分: 功能函数节点

### 5.1 `WorldPosition`世界位置

- 作用 :
	- 输出像素/顶点在世界坐标下的位置 .  为三维矢量 .
	- 根部不同的阶段输出不同的数据 ,  顶点着色器运行时输出顶点位置 .  像素着色器运行时输出像素位置 .

- 用法扩展 :
	- 输入UVs采样 .
		- 纹理会随着像素的位置移动而变换 ,  效果为纹理相对世界静止 .  平铺次数与模型大小有关 .


### 5.2 `ActorPosition`类世界位置

- 作用
	- 输出物体的父级世界坐标位置 ,  如蓝图里的静态网格体类 ,  此节点输出蓝图的世界坐标 .

- 用法扩展 :
	- 获得根据物体运动而变化的数值


### 5.3 `CamerPosition`相机世界位置

- 作用
	- 输出相机在世界的坐标位置 ,  注意 ,  不同的相机会有不同的效果 .


### 5.4 `ObjectPosition`物体世界位置

- 作用 :
	- 直接输出网格体的世界位置 .


### 5.5 `ObjectBounds`物体XYZ轴向边界长度

- 作用 :
	- 输出物体中心为原点XYZ轴方向至物体边界的长度 .


### 5.6 `ObjectRadius`物体半径

- 作用 :
	- 输出物体中心至最远边界的长度 , 输出标量 .


### 5.7 `ObjectOrientation`物体Z轴指向的方向 

- 作用 :
	- 输出物体Z轴指向的方向 .


### 5.8 `ScreenPosition`像素在窗口下屏幕位置

- 作用 :
	- 输出像素选在在屏幕上的UV坐标 .

- 返回值 :
	- Viewer Port UV : 输出单位化的数值 ,  像素在屏幕上的百分比位置 .
	- Pixel Position :  输出像素位置 ,  根据像素个数输出坐标 .


### 5.9 `PixelDepth` 相机至像素的距离

- 作用 :
	- 输出相机至像素的距离 .  也叫像素深度 .


### 5.10 `SceneDepth`场景深度

- 作用 :
	- 剔除与相机最近的像素 ,  输出距离相机第二近的像素点距离 .


### 5.11 `Depth Fade`深度消退

- 作用 :
	- 计算当前像素与背景像素之间的深度差 ,  计算一个渐变值, 用于混合透明物体颜色与背景颜色 .

- 伪代码实现
```c++
float DepthDelta = SceneDepth - PixelDepth; // 场景深度减去像素深度,获得背景像素与当前像素的距离. 由于Unreal单位的问题,此数值大于1.

float Fade = saturate(DepthDelta / FadeDistance); //由于数值过大,需要将其缩小数倍使用,此数值一并影响Fade的灰部强度.

```
- 参数列表 :
	- Opacity :  输入原本透明度
	- Fade Distance :  控制插值阈值 ,  值越大 ,  平滑范围越大 .

### 5.12 `Noise` `Vector Noise`噪音生成

- 作用 :
	- 生成一张噪波贴图 .


### 5.13`SphereMask`球形遮罩

- 作用 :
	- 以A为坐标矢量 ,  B为圆心 , Radius为半径生成输出常量的一维矢量 . 此节点为判断A输入的坐标如果在以B为中心 , Radius的球里 ,  则此节点输出1 ,  反之输出 0 ( 如果勾选Hardness, 则输出距离圆心到渐变值).

- 参数列表 :
	- `A`: 输入矢量 .
	- `B`: 输入圆心的位置信息 .
	- `Radius`: 输入半径 .
	- `Hardness`: 圆心开始到球边开始线性渐变 ,  此值决定了球边的常数值  .


## 第六部分 :  GPU运行时程序干涉(神秘的冷门节点)

### **6.1 `VertexInterpolator`顶点插值器**

**一. 作用 :**

- 顶点着色阶段 ,  将计算转换为顶点着色时计算 ,  并标记需要插值的数据 ,  存入插值寄存器 .  光栅化阶段时 ,  GPU 对插值寄存器中的数据进行线性插值( 透视矫正 ) ,  生成每个像素的输入值 .  在PixelShader 阶段时 ,  插值后的数据直接从插值寄存器读取 ,  跳过了像素着色器的计算阶段 .

- 作用总结为 :  通过将计算从高频率的像素着色器转移到相对低频的顶点着色器，减少像素着色器的计算负担，尤其适用于复杂材质或高密度网格。

**二. 使用须知 :**

- **优化寄存器压力**：  
    若在像素着色器中重复计算同一数据，可能占用更多通用寄存器；而通过 `VertexInterpolator` 提前计算并插值，可减少像素阶段的寄存器占用。

- **插值寄存器占用**：  
    `VertexInterpolator` 会占用额外的插值寄存器（如 `TEXCOORD` 通道），但通常比像素阶段的复杂计算更高效。

- **插值寄存器限制**：  
    GPU 的插值寄存器数量有限（如 OpenGL ES 中通常支持 8-16 个 `TEXCOORD`）。过度使用 `VertexInterpolator` 可能导致寄存器溢出，需谨慎分配。

- **精度问题**：  
    插值数据是线性计算的，高频信号（如细节噪声）可能出现失真，此类数据仍需在像素阶段计算。

### 6.2 `Feature Level Switch`

- 待补充

### 6.3 `Quality Switch`

- 待补充

### 6.4 `DDX / DDY`

- 待补充

## 第七部分 :  官方/本地 函数库

### 6.1 `CameraDepthFade`根据像素与相机的距离输出渐变Fade(float)

- 作用 :
	- 根据像素与相机的距离输出渐变Fade(float) ,  常用于特效效果优化 .

- 实现原理 :
```C++
float3 Temp = Camera_Position - World_Position;

return saturate((length(Temp) * dot(normalize(Temp) , ZVector) - FadeOffset ) / FadeLength) ;

// 参数列表 :
// FadeOffset 调整相机与像素之间的长度距离 (值越大, 输出的Fade越小.)
// FadeLength 调整输出Fade的强度. 
```

### 6.2`PirectDistanceSize`根据粒子的远近调整粒子的大小

- 作用 :
	- 常用于粒子优化 .  根据粒子距离相机的远近调整粒子的大小 .
- 实现原理
```c++
return (1 - clamp((distance(WorldPosition , CameraPosition) - CameraShinkOffset )  / CameraShinkDistance   , CameraShrinkMinScale , 1 )) * (ParticlePosition - WorldPosition);
```

### 6.3`ScreenAlignedPixelToPixelUVs`屏幕像素UV坐标

- 作用
	- 输出屏幕像素的UV坐标 .  常用于匹配后处理材质的分辨率 .

### 6.4`OpacityBasedDepthFade`根据背景进行的半透明深度优化

- 作用 :
	- 用于优化半透明物体与背景之间的过渡 ,  防止造成穿模的劣质感 .

- 伪代码
```c++
float OpacityBasedDepthFade(float FadeDistanceA, float FadeDistanceB, PixelAlpha)
{
	return saturate((SceneDepth - PixelDepth) / lerp(FadeDistanceA,FadeDistanceB,PixelAlpha)) * PixelAlpha;
}
```

### 6.5`CheapContrast`暗部收缩并增强对比度

- 作用:
	- 使用Lerp算法增强图像对比度 .


### 6.6`DitherTemporalAA`抖动TemporalAA

- 作用 :
	- 根据屏幕像素作为UV采样 ,  使模型上每个像素都输出不同的值 .  常用于产生模糊效果 .
	- 用于抗锯齿的运算 .

### 6.7 `WorldAlignedTexture`世界对齐纹理

- 作用 :
	- 脱离UV将纹理映射在模型上 .  

### 6.8 `ParallaxOcciusionMapping`视差偏移

**一. 参数列表详解 :**

- `Heightmap Texture`: 输入高度图 .  
- `Heightmap Channel`: 输入四维布尔值矢量 , 数值为1的对应分量即代表使用`Heightmap Texture` 的对应通道 .
- `Height Ratio`: 高度/深度 的倍率 .
- `Max Steps`: 最大步数 ,  控制不同模拟层之间的步幅 .  原理为重复采样对应地方的颜色 .数值越大 ,  效果越好 .  代码层面为控制一个`While`循环的次数 .  一般禁止超过60次 .  步幅参数可以根据Camera距离材质的远近动态调控 .
- `Min Steps`: 最小步数 ,  配合Camera进行动态调控功能 .  一般不修改 .

**二. 使用须知 :**

- 此函数有旋转Bug ,  并且无法修复 ,  请注意使用 .

---
## 第八部分: 后期处理材质

### 7.1 `PostProcess`后期处理的概念

**一. 介绍后期处理 :**

**1. 什么是后处理 ?**
- 后处理是渲染管线的最后一步流程 .  因此 ,  能够访问的数据也是最多的 .  

**2. 后期处理的功能 :**

- 自由的调色 .  甚至可以在透明物体渲染之前对齐的进行调色 ,  从而避免调色带来的影响 .

**3. 后期处理的Details :**

- `Exposure`曝光
	- `Min Brightness`: 最小曝光度 .
	- `Max Brightness`: 最大曝光度 .


**二. Post Process Material :**

**1. `Blendable Location` 渲染管线混合位置

- `After Tonemapping`: 色调映射之后 .




---
### 7.2 `SceneTexture`后期纹理

**一. 节点介绍 :**

- 作用 :
	- 将后期渲染完成的数据作为纹理直接输入至材质中 .
	- 此节点仅在`Post Process` ,  `Surface::Default Lit`模式中生效 .

- 常用的数据纹理 :
	- `PostProcessInput` 屏幕颜色 ,  输出四维矢量 .
	- `WorldNormal` 像素的世界法线 .
	- `SceneDepth` 场景深度

>`GPU Visualizer` 的使用 :
>	使用快捷键 `Ctrl + Shift + ,`激活此面板 .  作用为查看当前帧的渲染流程 .

>请记得将`Post Process Material` 的 `Blendable Location` 混合矢量进行修改 .  发生抖动错误时 ,  将`Blendable Location` 更改为 `Before Tonemapping`

**二. UV 输入接口 :**

**1. 使用须知 :**

- 输入UVs时 ,  请注意输入归一化的屏幕分辨率比例


### 7.3 `View Property`视图属性

**一. 使用与作用 :**

**1. 基本作用 :**

- 输出引擎显示窗口的属性信息 .

**2. 输出数值 :**

- 输出屏幕的分辨率信息 .  光栅化阶段的抗锯齿模糊信息等 .



---
# Ⅱ. HLSL 图形编程

> HLSL 是面向GPU的多线程并行API ,  其实际原理为逐象素依次计算 .

## 第一部分: 变量

### 1.1 将材质参数传递到ush

**作用 :**

* 将虚幻面板 蓝图编写界面的 变量 实时传递到编译器上去.

**方法 :**

* 新建 custom节点, 进入细节面板;
* 单击 Inputs ,点击 + 号, 创建接口;
* 将在引擎里输入数值, 并连接到接口上即可;

---

### 1.2 HLSL 基础数据类型

| 数据类型            | 解释                                     |
| ------------------- | ---------------------------------------- |
| bool 布尔型         | 1: true     /2: false                    |
| int 整形 (4字节)    | 整数 (-2^31 ~ 2^31-1 )                   |
| half 一半 (2字节)   | 范围: -60000 ~ 60000; (支持整形与浮点型) |
| float 单精度浮点型  | 小数(7位有效数字)                        |
| double 双精度浮点型 | 小数;(15-16位有效数字)                   |
| uint 正整形 (4字节) | 正整数 2^31(0 ~ 4294967295)              |

---

### 1.3 USH 布尔 bool

**解释 :** 

* 布尔型, 与枚举类似. 可以使用0和1代替;

```HLSL
bool b1 = 0;	//0代表false, 1代表true;
if(b1)
{
	return 1;
}
else
{
	return 2;
}
```

---

### 1.4 USH 整形 int

**解释 :**

* 整数型

```HLSL
int i1 = A + B;	//A,B为在Unreal 里输入的整形
return i1;
```

---

### 1.5 USH 轻整形 half

**解释 :**

* half 轻整数, 占用两个字节大小的内存.范围-60000 ~ 60000;

```c++
half h = 2;
return h; //输出2, 和int型一样. 区别为helf占用更小的内存(注意, 不要超出内存)
```

---

### 1.6 float 单精度浮点型

**解释 :**

* 浮点型, 表示小数; 占用8位内存
* 无法表示高精度浮点型;

```c++
float f = 1.666;
return f;
```

---

### 1.7 double 双精度浮点型

**解释**

* 更高精度的浮点型, 占用16位内存

```c++
double d = 1.111;
return d;
```

---

### 1.8 uint 无符号整型

**解释 :**

* 无符号整型, 范围为: 2^31(0 ~ 4294967295)

```c++
uint u = 1;
return u;
```

---

### 1.9 不同数据类型之间的转换

* 不同数据类型之间可以强制转换
* 不按照四舍五入进行计算, 直接向下取整.
* 注意, 转化时, 请注意数据范围, 否则会溢出.
* 支持隐式转换.

```c++
float test1 = 1.9;
int test2 = (int)test1; //直接向下取整

int test3 = -1;
uint test4 = test3; //内存溢出

return test4;
```



---

## 第二部分: 矢量

### 2.1 USF 模板定义数据类型定义矢量

**语法 :**

* `vectro<数据类型 , 分量数量(int)> 矢量名` 

**使用 :**

* `矢量名.(分量)` 
* 注意,在图形学中, 四维矢量的分量名称默认为: `RGBA` 和 `XYZW`

```c++
//方法一: 定义矢量
vector<float, 4> v4;
v4.xyzw = 0.f;
v4.x = 1.f;	//赋值方法, 类似c++的结构体;

return v4;	//反射红色
```

---

### 2.2 USF 简短的直接使用数据类型定义矢量

**语法 :**

* `数据类型+矢量数量 矢量名;`
* `float3 v1 = float3(0,0,0)` 

**初始化方法 :**

*  `数据类型+矢量数量 矢量名 =  数据类型+矢量数量(0,0,0,0);`
* 也可以先定义再初始化:`矢量名 = 数据类型+矢量数量(0,0,0,0);`
* `数据类型+矢量数量 矢量名 =  {0,0,0,0};`

```c++
float4 v = { 0, 0, 0, 1 };
float4 v2 = float4(0, 0, 0, 1);
v = float4(0,0,0,1);
```

---

### 2.3 USF `vector` 关键字定义矢量

 **语法 :**

* `vector 矢量名;` 

**初始值 :**

* `矢量名.需要修改的分量名 = 具体数值;`  `v.xyzw = 0.f` 

```c++
vector v1;
v1.xyzw = 0.0; //自动识别数据类型;
v1.x = 1.0;

return v1;
```

---

### 2.4 矢量的读写

**语法 :**

* 通过`.xyzw;` 直接访问;
* 通过`.rgba;` 直接访问;
* 通过下标访问: `矢量名[int];` 与数组一致;
* 通过叠词访问: `矢量名.rr = 0;` 访问前两个分量;

**使用须知 :**

* 可以直接使用矢量赋值矢量;

```c++
int v = {0,0,0,0};

v.x = 1;
v.r = 1;
v[0] = 1;
v.rr = 1;	//前两个分量都为1;

//使用矢量直接赋值矢量
v.x = v[0]; 
```

----

### 2.5 强制转换

**一. 解释 :**

* 当矢量转换为变量时, 取矢量的第一个分量.
* 变量强制转换为常量时, 数值赋予给第一位矢量.

```c++
float4 test1 = {0,1,1,1};
test1.x = 0.6;

float test2 = test1;    //矢量转变量,取矢量的第一个分量

float4 test3 = test2;   //变量转矢量,取变量的值为矢量的第一个分量

float3 test4 = test3;   //高纬矢量转低纬矢量,取高位矢量的前低纬矢量分量数量个分量的值.

return test4;   //输出0.5
```



---

## 第三部分: 矩阵

### 3.1 矩阵的数学定义

* 由m行 n列元素构成的矩形阵列, 叫做矩阵.

**一. 解释 :**

* 线性代数中的矩阵常用于解决图形学上常见的实际问题. 详细阅读< 3D数学基础 >.

---

### 3.2 矩阵的定义

**语法 :**

* `数据类型+nxm 矩阵名;`

```c++
int3x3 i;  
return 0;
```

---

### 3.3 使用matrix关键字的矩阵的定义

**语法 :**

* `matrix<数据类型 , m , n > 矩阵名+mxn;` 

```c++
matrix<int, 3, 3> m3x3;
return 0;
```

---

### 3.4 矩阵的初始化

**语法 :**

* `数据类型+mxn 矩阵名mxn = {具体元素};`
* `数据类型+mxn 矩阵名 = {具体元素};`
* 使用矢量构成矩阵: 前提, 分量的数量需一致.`数据类型mxn 矩阵名 = 数据类型mxn(分量名,分量名,分量名);`

```c++
int2x2 i2x2 = {	//普通方法
    0.f, 0.f,
    0.f, 0.f
};

int2x2 i = {	//简便方法
    0,0,
    0,0
};

int3 a1 = {0,0,0};
int3 a2 = {0,0,0};
int3 a3 = {0,0,0};

int3x3 m1 = int3x3(a1,a2,a3);	//使用矢量初始化矩阵
```

---

### 3.5 矩阵的读写

**解释 :**

* 矩阵可以使用下标进行读写(程序定义). 
* 矩阵可以通过脚标读写(数学定义).

**语法 :**

* `数据类型 矩阵名 = 矩阵名.m(数组行标)(数组列标);`
* `数据类型 矩阵名 = 矩阵名.[m][n];`
* `数据类型 矩阵名 = 矩阵名._i(数学行标)j(数学列标);`
* 使用数学表达法时, 可以一次读取多个数值:
  * `数据类型 矩阵名 = 矩阵名._i(数学行标)j(数学列标)_i(数学行标)j(数学列标);`等 

```c++
float f1 = m1.m00;	//f1 是变量, m1是矩阵;
float f2 = m1.m11;
```

---

### 3.6 矩阵的反对转置

**解释 :**

* 在CPP传递矩阵至HLSL时, 会自动转置矩阵, 使用此关键字可以逆转置

**语法 :**

* `row_major matrix 矩阵名;` 

```c++
row_major matrix 矩阵名;
```

---

## 第四部分: HLSL修饰符

### 4.1 static静态变量

**解释 :**

* 当变量以静态的方式定义时, 此变量仅能用于链接内部链接, 这意味着改变量仅在声明它的编译单元内可见.

**语法 :**

* 在定义变量前加`static` 即可.

```c++
static int3 i = {0,0,0};
return 0;
```

---

### 4.2 const限制常量

**解释 :**

* const修饰变量为不能修改. 变量变成逻辑上的常量.

**语法 :**

* 声明变量时在前面加`const` 

```c++
const int3 i = {0,0,0};
return 0;
```

---

### 4.3 typedef初始化

**解释 :**

* 使用 变量\矢量\矩阵 的数值, 初始化新 变量\矢量\矩阵;
* 类似结构体, 使用已经定义的变量名取定义新变量名

**语法 :**

* `typedef 数据类型+分量数量 矢量名; 矢量名 新定义的矢量名 = 数据类型+分量数量(数值);`

```c++
typedef const int3 i1;
i1 i2 = {0,0,0};	//使用i1 直接定义 i2 为 int型, 三个分量的矢量.
return 0;
```


### 4.4 `register()`显式变量寄存器分配

**1. `register()`的概念:

- `register()` **不是函数**，而是一个 **语法修饰符**，用于显式指定资源（如纹理、采样器、缓冲区等）绑定到 GPU 的硬件寄存器。

- 在 HLSL 中，所有需要访问的 GPU 资源（如纹理、采样器、常量缓冲区）必须分配到特定的寄存器中，以便着色器正确访问它们


**2. 寄存器前缀 :**

- `t*`: 纹理寄存器（如 `t0`, `t1`）。
- `s*`: 采样器寄存器（如 `s0`, `s1`）。
- `b*`: 常量缓冲区寄存器（如 `b0`, `b1`）。

**3. `register()`的作用 :

- 显式控制资源在 GPU 寄存器中的位置，避免自动分配导致的冲突。
- 在多渲染阶段（如顶点着色器、像素着色器）共享资源时，确保寄存器一致性。

**4. 语法与用途 :**
```c++
// 声明纹理并绑定到寄存器 t0
Texture2D MyTexture : register(t0);

// 声明采样器并绑定到寄存器 s0
SamplerState MySampler : register(s0);

// 声明常量缓冲区并绑定到寄存器 b0
cbuffer MyConstants : register(b0) {
    float4 Color;
    float Scale;
};
```

**5. 使用须知 :**

- **默认行为**：如果省略 `register()`，HLSL 编译器会自动分配寄存器，但可能导致不可预测的绑定冲突。

- **必须手动指定的场景**：

	1. 多个着色器共享同一资源（如多个 Pass 使用同一纹理）。
    1. 需要精准控制资源绑定的优化场景（如减少寄存器压力）。
    2. 在复杂渲染管线中与其他系统（如 Unreal Engine）交互时。


## 第五部分: HLSL中的结构体和数组

### 5.1 数组的定义, 初始化 与 读写

**一. 定义数组 :**

* `数据类型 数组名[元素个数];` 
* 数据类型包括: 变量, 矢量.

---

### 5.2 struct 结构体

**一. 语法 :**

* `struct 结构体名 {数据类型 变量名; 数据类型 变量名;等等}`

**二. 解释 :**

* 结构体的内存计算 :
  * 所有数据类型对齐至内存最大的数据类型.
  * 比如: 有三个内存, 为int,int,float, 则内存的计算按最大的内存乘以结构体数据类型数量.

**三. 结构体赋值 :**

* 结构体的本质是公开权限的类, 因此赋值方法为:
* 定义类对象
* 访问对象成员变量:`对象名.成员变量;` 

```c++
struct FTestStruct 
{
    float A;
    float2 b;
    float4x4 c;
}

FTestStruct F1;
F1.A = 1.0f;

retuen F1.A;
```

---

## 第六部分: 运算符

### 6.1 加减乘除

* 使用运算符, 组成表达式. 返回一个值
* 注意, 乘法比除法运算更快
* 注意, 整数运算比小数运算更快

**注意, 对矢量之间的运算符合它的数学方式**

---

### 6.2 模运算

* `%` 取余符号, 常用语判断是否能够被整除

---

### 6.3 自增自减

* `++` `--` 符号, 与c系差不多.

---

### 6.4 关系运算符

* 大于,小于, 不大于, 不小于, 大于等于, 小于等于, 等于, 不等于

---

### 6.5 逻辑运算符

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

---

### 6.6 复合运算符

* `+=` `/=` `%=` 等
* 展开为: `i = i + 10;`

---

### 6.7 优先级

* `()` 强制先计算括号里的,

---

### 6.8 三目运算符

* `表达式1 ? 表达式2 ：表达式3`

---

## 第七部分: 条件语句

| if(表达式){}else if(表达式){}else{}       | 同C++, 但尽量不要使用过多的嵌套. |
| ----------------------------------------- | -------------------------------- |
| switch(表达式)case 数值:{}case 数值:{};等 | 适用于枚举等                     |

---

### 7.1 discard 丢弃像素

* 将此shader内所有的像素丢弃掉.
* 丢弃掉的像素视图上呈现灰色.

---

### 7.2 branch 动态分支选择性编译

* 根据条件, 选择性的编译判断语句中的内容. 正常来说, 编译器在编译时, 会先编译全部的代码. 但使用了branch语句, 它只会编译条件选择时, 执行的代码.这样可以节约内存以及计算量
* 减少消耗的内存, 增加计算的步骤

**语法 :**

* `[branch]` 
* 在没有书写`[branch]`时, 编译器也会自动选择如此运行.



---

### 7.3 flatten 全部编译

* `[flatten]`
* 无视条件, 全部编译所有条件语句的分支. 
* 消耗更多的内存, 减少计算的步骤

---

## 第八部分: 循环语句

| 语法                                                         | 作用          |
| ------------------------------------------------------------ | ------------- |
| for(循环前执行;条件;循环后执行), 使用`break;` 结束循环     `continue` 结束本次循环 | for循环       |
| while(条件), 使用`break;` 结束循环     `continue` 结束本次循环 | while循环     |
| `do{ }whlie(判断条件) ;`                                     | do..while循环 |

---

### 8.1 [loop] 

* 动态选择编译, 假设对循环次数是未知, 使用`[loop]` 
* 灵活.速度不会快, 但内存会小.
* 不会一开始就全部展开, 而是每一次都进行排酸

---

### 8.2 [unroll] 

* 对已知的展开次数进行全部展开, 如要编译100次, 则将100次全部展开. 耗费更多的显存
* 速度会更快, 但内存会变得很大

---

## 第九部分: HLSL纹理采样

### 9.1 Texture2DSample纹理采样函数

**1. 用法 :**

* 此函数返回的数据类型为` float4`, 可以用`float4` 接收 .
* 此函数参数列表:`([纹理贴图], [采样模式], [UV])` 

**2. 语法 :**

* `Texture2DSample(Texture, TextureSampler, UV);` 

```c++
float4 test01 = Texture2DSample(Texture, TextureSampler,UV);//采样模式的定义为 贴图纹理名称 + 采样方式 .  并不是统一名称 .

return test01;
```

**一. 使用须知 :**

* 参数列表中 :  样模式的定义为 贴图纹理名称 + 采样方式 .  并不是统一名称 .
- 注意, 不得输入纹理采样 ,  必须输入纹理对象 .

**二. 采样的渲染管线过程 :**

- 纹理采样的过成中 ,  模型的像素会询问自己采样纹理对象的那一个纹素 ,  决定采样哪一个纹素的 ,  叫做UV坐标 .  (注意 ,  顶点UV坐标不是在DDC软件展UV时确定的 ,  DDC软件展UV时确定的仅仅是影响顶点UV坐标运算的一个过程 .)

**1. 顶点着色阶段 :**

- 默认情况下 ,  纹理的UV坐标默认是线性的`[0,1]`值域的 .  正常情况下 ,  模型的顶点会平铺在二维空间中 .  我们需要使用Texcoord ,  配合DDC软件中手动赋予的UV进行计算UV坐标 ,  此刻的情况下 ,  顶点的UV坐标为DDC软件中制作的UV坐标 .( 常规操作 )

- 但我们可以手动赋予模型的UV坐标 ,  相当于使用程序给模型重新展UV .  我们手动赋予UV坐标之后 ,  采样节点将使用我们赋予的顶点UV坐标进行采样 .

**2. 光栅化阶段 :**

- 光栅化阶段 ,  我们需要运算像素的UV坐标 ,  为像素着色做准备 .  根据顶点的UV坐标 ,  进行线性插值 ,  求出像素的UV坐标 .

**3. 像素着色阶段 :**

- 根据光栅化求出的像素UV坐标 ,  像素分别采样纹理对象相应的颜色信息 ,  并经过一系列程序后 ,  显示在光栅化设备上 .  

**4. 使用须知 :**

- 我们常用的手法 ,  都只能改变或影响顶点的UV坐标 .  UV坐标需要我们手动输入 .  采样器不具有计算UV坐标的功能 .  当然 ,  Unreal 为了兼顾傻瓜们的操作 ,  在没有输入UV坐标的情况下会帮我们输入Texcoord使用默认的DDC软件中赋予的UV坐标 .  但这不能代表采样器有计算UV坐标的功能 .  请谨记不要搞混 .



---

### 9.2 `SamplerState`纹理采样

**一. `SamplerState`纹理采样器的概念 :

- `SamplerState` 是 HLSL 中的一种==变量类型==，用于定义如何从纹理中采样数据。
- 它控制采样时的过滤模式（Filtering）、寻址模式（Addressing）和其他采样行为（如各向异性过滤）。

**二. `SampleState`的核心属性及其枚举作用 :**

- `SampleState`的核心参数为 : `Filter`(过滤模式) , `AddressU` `AddressV`(寻址模式) .
- 其中 ,  过滤模式控制纹理在放大 ,  缩小或切换Mipmap层级时 ,  如何对纹素进行插值计算 ,  直接影响纹理的平滑程度和清晰度 ;  而寻址模式控制纹理坐标超出$[0 , 1]$范围时的行为 ,  定义重复或截断方式 .

**1. Filter :**

* `MIN_MAG_MIP_POINT`
	* 原理 :  最近邻插值 Nearest Neighbor 
	* 效果 :  采样时直接去最近的单个像素 ,  纹理边缘锐利 ,  会有锯齿 .

- `MIN_MAG_LINEAR_MIP_POINT`
	- 原理 :  双线性插值 ,  Mipmap切换时使用最近邻值 .
	- 效果 :  平滑纹理 ,  保留Mipmap层级的锐利切换 .

- `MIN_MAG_MIP_LINEAR`
	- 原理 :  所有情况均使用 三线性插值 (双线性插值 + Mipmap层级间插值)
	- 效果 :  平滑过渡 ,  但可能模糊细节

- `ANISOTROPIC`各向异性过滤
	- 原理 :  根据视角方向动态调整采样范围 ,  解决倾斜表面纹理模糊 .
	- 效果 :  高度下保持纹理清晰 ,  如墙面 ,  地面等 .  但需要高性能支持 .
```c++
SampleState TestSample : register(s0)
{
    Filer = ANISOTROPIC;
    MaxAnisotropy = 16; //最大各向异性等级
}
```


**2. `AddressU`和`AddressV`

- `Warp`平铺
	- UV超出范围时重复纹理 ,  如瓷砖等 .

-  `Clamp`钳制
	- UV超出时 ,  取边缘像素颜色 .

- `Mirror`镜像
	- UV超出时镜像重复纹理

- `Border`自定义边框颜色
	- UV超出时返回自定义的颜色 .  需要定义变量`Bordercolor`
```c++
SampleState BorderSample : register(s0)
{
    AddressU = Boeder;
    AddressV = Border;

    BorderColor = float4(0.5,0.5,1,1);    //定义边框颜色
}
```


**二. 采样模式及其作用与原理 :

**1. 过滤模式（Filtering Mode)**

- 控制如何从纹理像素（Texel）插值生成最终颜色。

 **(1) 点过滤（`Point`/`Nearest`）**

- **原理**：直接取最近的纹理像素，无插值。
- **效果**：像素化、锯齿明显。
```c++
// 示例：点过滤采样
	SamplerState PointSampler : register(s0) { Filter = MIN_MAG_MIP_POINT; };
```

**(2) 线性过滤（`Linear`/`Bilinear`）**

- **原理**：对最近的 2x2 纹理像素进行双线性插值。
- **效果**：平滑过渡，边缘模糊。
```c++
// 示例：线性过滤采样
    SamplerState LinearSampler : register(s1) { Filter = MIN_MAG_MIP_LINEAR; };
```
**(3) 各向异性过滤（`Anisotropic`）**

- **原理**：沿视角方向动态调整采样范围，解决倾斜表面纹理模糊。
- **效果**：高角度下纹理更清晰。
```c++
// 示例：各向异性过滤（16x）
SamplerState AnisoSampler : register(s2) { Filter = ANISOTROPIC; MaxAnisotropy = 16; };
```


**2. 寻址模式（Addressing Mode）**

- 定义纹理坐标超出 [0,1] 范围时的行为。

**(1) Wrap（重复）**

- **原理**：纹理在 UV 方向无限重复。
    
- **效果**：平铺贴图。
```c++
SamplerState WrapSampler : register(s3) { AddressU = Wrap; AddressV = Wrap; };
```
**(2) Clamp（截断）**

- **原理**：超出范围的 UV 使用边缘颜色。
    
- **效果**：避免边缘拉伸。
```c++
SamplerState ClampSampler : register(s4) { AddressU = Clamp; AddressV = Clamp; };
```

**(3) Mirror（镜像）**

- **原理**：镜像重复纹理。
- **效果**：无缝对称图案。
```c++
SamplerState MirrorSampler : register(s5) { AddressU = Mirror; AddressV = Mirror; };
```


**3. Mipmap 过滤**

- **原理**：根据纹理距离自动选择合适大小的 Mipmap 层级。
- **模式**：
    
    - `MipPoint`：使用最近的 Mipmap 层级。
        
    - `MipLinear`：在相邻 Mipmap 层级之间线性插值。


**三. 声明语法 :**

**1. 自动生成采样器 :**
- 当在材质编辑器中添加纹理采样节点时，Unreal Engine 会自动生成以下内容：
```c++
// 自动生成的代码示例
TEXTURE2D(MyTexture);                // 声明纹理
SAMPLER(sampler_MyTexture);           // 声明采样器，名称格式为 "sampler_TextureName"
```


**2. 手动声明 :**
* 如果完全手写 HLSL 代码，需显式声明：
```c++
SamplerState MySampler : register(s0); // 手动声明采样器
```



### 9.3  立方体纹理

* 常用于: 立方体, 环境球, 天空球等.
* 使用: 前后, 左右, 上下等面拼接起来.

**1. 用法 :**

* 使用立方体纹理时, 只需要将函数中的2D改为3D即可.
* 输入UV时, 请输入反射法向

```HLSL
float4 test01 = Texture3DSample(Texture, TextureSampler,UV);

return test01;
```

---

## 第十部分: 自定义函数库

---

### 10.1 定义局部函数

**1. 用法 :**

* 因为shader 默认写在函数里 ,  因此常用的方法是用`struct`关键字封装一个类 .

---

### 10.2 侵入式全局函数

**1. 方法 :**

* 全局函数: 头文件与源文件写在一起.
* 定义地点: 
  * `引擎地址(不是项目地址) > Engine > Shader > public > 全局文件创建在这里`
    * 在`引擎地址 > Engine > Shaders > Private > Common` 中引用文件(注意写相对路径,[模板]:  `#include "/Engine/Public/.ush"`)
  * 以后, 只需要维护一个函数文件即可.

## 第九部分: 数学函数

### 1. 第一章

### 1.1 `abs` 求绝对值

**1. 用法 :**

* `abs()` 
* 括号里输入变量, 矢量. 返回一个变量或矢量
* 将全部的变量或矢量转换为正数

```HLSL
float4 test1 = {-1.0f,0.f,0.f,1};
return abs(test1);	//返回红色
```

---

### 1.2 `cos` 余弦函数

**1. 用法 :**

* `cos()` 
* 返回一个矢量或数值

**2. 数学意义 :**

* `cos(0) = 1;` `cos(π / 2) = 0`
* 可以输入角度, 根据得到是数值判断
* 搭配绝对值做出明暗效果

---

### 1.3 `acos` 反三角函数

**1. 用法 :**

* `acos()` 
* 输入`cos`函数在`y` 轴的数值, 得到`cos` 函数在`x` 轴上的角度.
* 注意, 此函数输出弧度

---

### 1.4 `degrees()` 弧度转换角度

**1. 用法 :**

* 将弧度转换为角度

---

### 1.5 `all()` 且判断函数

**1. 用法 :**

* 判断矢量里的所有分量是否为true, 若均为true, 则返回true. 返回一个布尔值
* 类似逻辑判断.

```c++
bool4 test01 = {1,1,1,1};
return all(test01); //返回布尔值
```

---

### 1.6 `any()` 或判断函数

**1. 用法 :**

* 只要分量里有一个为true, 则结果为true

```c++
bool4 test01 = {1,0,0,0};
int test02 = any(test01);
return test02; //返回1
```

---

### 1.7 `ceil()` 向上取整

**1. 用法 :**

* 输出整形, 只要有小数, 则输出整数部分+1;
* 如果输入矢量, 则应用于所有分量.

```c++
float test01 = 1.1;
float4 test02 = {1.1,2.1,3.1,4.1};

return ceil(test02);    //输出2
```

---

### 1.8 `floor()` 向下取整

**1. 用法 :**

* 输出整形, 只要有小数, 则去掉小数部分.

```c++
float test01 = 1.1;
float4 test02 = {1.1,2.1,3.1,4.1};

return floor(test02);    //输出2
```

---

### 1.9 `clamp()` 限制函数

**1. 用法 :**

* `clamp(变量矢量, 最小数值, 最大数值)`
* 给变量/矢量的各个分量显示取值范围.

```c++
float test01 = 5;
float4 test02 = {2,3,4,5};
float4 test03 = clamp(test02,3,4);

return test03;    //输出[3,3,4]
```

---

### 1.10 `clip()` 丢弃小于等于0的像素.

**1. 用法 :**

* 当像素小于等于0时, 丢弃这个像素;
* 无返回值

```c++
float4 test01 = {-1,-1,-1,1};
clip(test01);
return test01;
```

---

### 1.11 `cosh()` 双曲线函数	==?==

**1. 用法 :**

> 双曲线公式: `(exp(x) + exp( -x) ) / 2.0` 其中 e 是自然对数的底数(约等于 2.71828)

* 可以调整亮度

---

### 2. 第二章

### 2.1 `countbits()` 二进制统计1的数量

**1. 用法 :**

* 按位进行计算. 统计数值转化的二进制文件中, `1` 的数量

```c++
uint test01 = 100;

return countbits(test01);   //输出3
```

**2. 实现原理 :**

```c++
Uint countbits(){
    uint count = 0;
    while(x >0)
    {
        count += x & 1;
        x >>= 1;    //右移一位
    }

    return count;
}
```

---

### 2.2 `corss()` 叉乘

**1. 用法 :**

* `corss(矢量, 被叉乘矢量)` 得出叉乘结果. 

```c++
float3 test01 = {1,0,0};
float3 test02 = {0,1,0};

float3 test03 = cross(test01,test02);
return test03;	//输出[0,0,1]
```

**2. 使用须知 :**

* 叉乘可以处理三维矢量, 无法处理思维矢量.4

---

### 2.3 `dot()` 点乘

**1. 用法 :**

* `dot(矢量1, 适量2)` 
* 求出投影长度

---

### 2.4 `distance()` 点到点的距离

**1. 作用 :**

* `distance(矢量, 矢量);` 

---

### 2.5 `fmod()` 取余函数

**1. 作用 :**

* `fmod(被除数, 除数)` 
* 返回余数

---

### 2.6 `frac()` 取小数函数

**1. 作用 :**

* `frac(类)` 

---

### 2.7 `length()` 取向量长度

**1. 作用 :**

* `length(起始点矢量, 终点矢量);`

---

### 2.8 `step()` 比较函数

**1. 作用 :**

* `step(a, b);` 
* 如果b比a大, 返回一, 反之, 返回0;
* 如果比较分量的话, 返回的也是分量. 但是每个分量是比较分量的后的结果.

---

### 2.9 `trunc()` 返回整数部分

**1. 作用 :**

* 返回整数部分
* 作用 : 使坐标离散化, 以及例子中随时间离散的步长

---

### 2.10 `lerp()` 线性插值

**1. 作用 :**

* `lerp(a, b, c);` 
* 线性插值, 根据c的值走 a , b 的比例.

---

### 3. 第三章

### 3.1 `ddx() and ddy()` DDX 与 DDY

**1. 作用 :**

* GPU在像素着色阶段使用`ddx / ddy`计算 ,  

---

### 3.2 `isnan()` 检测是否为无效值

**1. 用法 :**

* 检测float是否为无效值, 输出`true`, 否则输出`flase`
* 如果输入矢量, 则返回BOOL型的矢量

```c++
float test01 = 0;
float test02 = 0;

float3 test03 = test01 / test02;

bool test4 = isnan(test03);

return test4;	//是无效值返回1, 是有效值返回0;

//使用场景
float4 color = GetColor();
if (isnan(color.r)){
    color.r = 0.0; //如果红色通道为NALL, 将其替换为 0;
}
```

---

### 3.3 `isfinite()` 检测是否为有限数

**1. 用法 :**

* `isfinite()` 参数列表输入变量或矢量, 如果其是有限数, 则返回true, 否则返回flase

```c++
float f1 = 1.0;
float f2 = 1.0 / 0;
float f3 = 0.0 / 0.0;

bool b1 = isfinite(f1); //有限数
bool b2 = isfinite(f2); //为无限大
bool b3 = isfinite(f3); //为NAN

return b2;  //b1 返回1; b2 返回0; b3 返回0;
```

**2. 使用场景 :**

```c++
float4 position = GetPosition();
if(!isfinite(position.x) || !isfinite(position.y) || !isfinite(posoton.z)){
    //如果位置的任意一个分量不是有限数, 执行错误处理或者跳过
    DIscard();
}
```

---

### 3.4 `exp()` 和 `exp2()` 幂函数	==?==

**1. 用法 :**

* `exp(int)`  e^int 次方, e 的 int 次方.
* `exp2(int)`  2的int次方;

```c++
float f1 = 1.0;

float f2 = exp(f1); //e的f1次密;
float f2 = exp2(f1);	//2的 f1 次幂

float3 v1 = {1,1,1};

float3 v2 = exp(v1);    //对v1的每个分量作e的次幂运算.
float3 v2 = exp2(v1);    //2 的 f1 次幂
```

**2. 使用场景 :**

* 锐化图形
* 配合双曲线运算

---

### 3.5 `isinf()` 判断是否为无穷大小

**1. 作用 :**

* `isinf()` 输出布尔值, 如果为无穷大或无穷小, 则输出true. 否则输出flase
* 负无穷小也输出true

```c++
float f1 = 1.0;
float f2 = 1.0 / 0;
float f3 = 0.0 / 0.0;

bool b1 = isinf(f1); //有限数
bool b2 = isinf(f2); //为无限大
bool b3 = isinf(f3); //为NAN

return b2;  //b1 返回0; b2 返回1; b3 返回0;
```

---

### 3.6 `log()` 对数	==?==

**1. 用法 :**

* 自然对数运算 以e为底, x的对数
* `log2()` `log10()` 就是以 2 为底, 或者是以 10 为底.

---

### 3.7 `max()` `min()` 最大最小

**1. 用法 :**

* 参数列表为两项, 分别输入矢量或变量, 返回比较这两个中最小或最大的值.

```c++
float3 v1 = {0.1,0.1,0.5};

float3 v2 = {0.3,0.3,0.1};

return max(v1,v2);  //[0.3,0.3,0.5]
```

---

### 3.7 `modf()` 拆分float函数

**1. 用法 :**

* 拆分一个浮点型. 将其拆分为矢量.
* `储存小数部分变量` = `modf`(`需要拆分的浮点型` , `储存整数部分变量`)

```c++
float f1 = 1.75f;
float2 v1;

v1.y = modf(f1, v1.x);

return v1;	//v1 = [1, 0.75];

//modf() 函数也可以应用于向量
float3 f1 = {2.5,3.6,4.7};
float3 v1;

float3 v2 = modf(f1, v1);

return v2;	//v2 = {0.5,0.6,0.7};
			//v1 = {2, 3, 4};
```

---

### 3.8 `normalize()`转换为单位向量

**1. 用法 :**

* 给定一个向量, 输出此向量的单位向量. 坐标中心为向量起点.

---

### 3.9 `rcp()`被除以1

**1. 用法 :**

* 将输入的数字被除以1.f;
* 小数运算除法, 运算速度慢.
* 支持矢量与矩阵.

```c++
float f1 = rcp(5);  //1.f/5
    
return f1;  //输出0.2
```

---

### 4. 第四章

### 4.1 `sqrt()`和`rsqrt()`根号运算

**1. `sqrt()`用法 :**

* 将输入的数字做平方根运算
* 支持矢量与矩阵

```c++
float f1 = 4;

return sqrt(f1); //根号下4 = 2
```

**2. `rsqrt()`根号运算被除以1:**

* 将输入的数字做平方根运算后, 被除以一, 倒数运算.
* 支持矢量与矩阵

```c++
float f1 = 4;

return sqrt(f1); //根号下4 = 2, 1/2 = 0.5;
```



---

### 4.2 `round()`四舍五入

**1. 用法 :**

* 将输入的数字做四舍五入

```c++
float f1 = 2.5;
return round(f1);	//输出3
```

---

### 4.3 `reflect()`反射计算

**1. 用法 :**

* 参数列表输入: 入射向量, 法线向量. 返回反射向量 
* 解释 :  光打在平面上 ,  光会根据面发现反射出去 .  此函数则返回反射的方向 .

```c++
float3 incident = {1.0, -1.0, 0.0};   //入射向量
float3 normal = {0.0, 1.0, 0.0};    //法线向量

float3 reflected = reflect(incident, normal);   //计算反射向量, 结果是float3(1.0, 1.0, 0.0);
```

---

### 4.4 `refract()`折射

**1. 用法 :**

* 玻璃等半透明物体有折射率 ,  光照在半透明物体上时穿过会有折射率 .  
* 参数列表 :  入射向量 ,  法线 ,  折射率

```c++
float3 incident = { 1.0, -1.0, 0.0 }; //入射向量
float3 normal = { 0.0, 1.0, 0.0 };  //法线
float eta = 1.0 / 1.5; //折射率

float3 refracted = refract(incident, normal, eta); //计算折射方向
```

---

### 4.5 `reversedVal()`逆转Val

**1. 用法 :**

* 图形计算时的纹理映射 ,  加速数据处理或特殊场景编码等

```c++
uint Test01 = 13;
uint reversedVal(Test01);

return reversedVal;
```

---

### 4.6`saturate()`硬件钳制0-1之间

**1. 用法 :**

* 将输入的数据钳制在0-1之间 .

```c++
uint Test01 = 13;
uint Test02 = saturate(Test01);

return Test02;
```

---

### 4.7 `smoothstep()`平滑过渡

**1. 作用 :**

* 返回一个平滑的过渡值
* `smoothstep(变量1 , 变量2 , 平滑参数);`

---

### 4.8 `sign()`根据正负返回1和-1

**1. 作用 :**

* 大于0 ,  返回 1;  小于0 ,  返回 -1 ;  等于0 ,  返回0;
* `Sign(变量);`

---

### 4.9 `sinh()`双曲正弦值

**1. 作用 :**

* 注意 ,   不是sin曲线 ,  是两头大中间平滑的曲线 .
* 参数列表输入 X 轴的值 ,  返回 Y 轴的值 . 

```c++
sinh(x轴的值);
```

---

### 4.10 `mad()`相乘再相加

**1. 作用 :**

* 参数列表 三个变量ABC . 
* 返回 A * B + C

---

### 4.11 `lit()`精简的光照函数 ==?==





---

### 4.12 `mul()`相应分量相乘

**1. 用法 :**

* 输入矢量或矩阵 ,  相同下标的分量或元素相乘组成新矢量或矩阵 .

```c++
float3 f1 = {1.0, 2.0, 3.0 ,4.0};
float3 f2 = {0.0, 1.0, 2.0, 3.0};

float3 f3 = mul(f1 , f2); //得到(0.0,2.0,6.0,12.0);
```



---

### 4.13`determinant()`计算矩阵行列式

**1. 用法 :**

* 在矩阵是方阵的前提下 ,  计算矩阵的行列式 .  det = 0 代表矩阵不可逆 .

---

### 4.14`transpose()`行列式转置

**1. 用法 :**

* 输入行列式 ,  得到行列式的转置 .



---

### 4.15 `tan()`三角函数tan

**1. 用法 :**

* 当x = 0.785 ,  则tan = 1 ;



---

### 5. 第五章

### 5.1 `radians()`角度转弧度

**1. 用法 :**

* 输入角度 ,  转弧度 .



---

### 5.2 `pow()` 求x的y平方

**1. 用法 :**

* `pow(x , y)` x 的 y 次方 . 



---

### 5.3 `tanh()`双曲切线 ==?==





---

### 5.4 `atan()`反切线

**1. 用法 :**

* 几何解释 :  在三角形中 ,  输入对边长度以及邻边长度 ,  求出弧度 .
* 图形解释 :  在二维笛卡尔坐标系中 ,  输入X , Y的数值 , 求出距离原点的角度 .

```c++
float opposite = 1.0;	//对边长度
float adjacent = 1.0;	//邻边长度

float angle = atan(opposite , adjacent);	//得出角度
```

---

### 5.5`atan2()`点到原点的弧度

**1. 用法 :**

* 在二维坐标系中 ,  输入X, Y ,  得到这个点到原点连成的线的弧度 .  比`tan2()`更精确



---

## 第十部分:  顶点像素 系统语义

### 10.1 `POSITION`顶点着色器位置

- 作用 :
	- 输入顶点着色器 ,  表示顶点的位置 .  在片元着色器中 ,  也可以用于代表屏幕空间下顶点的位置 ,


### 10.2 `NORMAL`顶点着色器法向

- 作用 :
	- 顶点着色器下顶点的法线 ,  同样能应用于片元着色器


### 10.3 `TEXCOORD0`顶点着色器uv输入

- 作用 :
	- 语法为`TEXCOORD` + `单个数字` ,  表示顶点着色器下UV采样时UV的输入 .  表示顶点的纹理坐标 .  片元着色器时表现采样的顶点纹理 .


### 10.4 `BLENDWEIGHT`属性混合

- 作用 :
	- 混合顶点的属性 ,  常用于蒙皮等 .


### 10.5 `TANGENT` `BINORMAL` 切线 次切线


### 10.6 `COLOR`颜色

- 作用 :
	- 可以表示顶点颜色或像素颜色 .



## 第十一部分: Unreal 内置宏

**一. 虚幻引擎内置宏源码及其文件位置 :**

- Unreal 的内置宏源码储存在`Engine\Source\Runtime\RenderCore\Public`文件中 .

**2. 源码表达 :**

```c++
struct FShaderMaterialPropertyDefines
{
	//DECLARE_TYPE_LAYOUT(FShaderMaterialPropertyDefines, NonVirtual);

	//void ModifyEnvironment(FShaderCompilerEnvironment& OutEnvironment) const;
	//void WriteFrozenVertexFactoryParameters(FMemoryImageWriter& Writer, const TMemoryImagePtr<FShaderMaterialPropertyDefines>& InPropDefines) const;

	uint8 MATERIAL_ENABLE_TRANSLUCENCY_FOGGING : 1;

	uint8 MATERIALBLENDING_ANY_TRANSLUCENT : 1;
	uint8 MATERIAL_USES_SCENE_COLOR_COPY : 1;
	uint8 MATERIALBLENDING_MASKED_USING_COVERAGE : 1;

	uint8 MATERIAL_COMPUTE_FOG_PER_PIXEL : 1;
	uint8 MATERIAL_SHADINGMODEL_UNLIT : 1;

//shading Mode
	uint8 MATERIAL_SHADINGMODEL_DEFAULT_LIT : 1;
	uint8 MATERIAL_SHADINGMODEL_SUBSURFACE : 1;
	uint8 MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN : 1;
	uint8 MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE : 1;
	uint8 MATERIAL_SHADINGMODEL_CLEAR_COAT : 1;
	uint8 MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE : 1;
	uint8 MATERIAL_SHADINGMODEL_HAIR : 1;
	uint8 MATERIAL_SHADINGMODEL_CLOTH : 1;
	uint8 MATERIAL_SHADINGMODEL_EYE : 1;
	uint8 MATERIAL_SHADINGMODEL_SINGLELAYERWATER : 1;
	uint8 SINGLE_LAYER_WATER_SEPARATED_MAIN_LIGHT : 1;
	uint8 MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT : 1;

//Blend Mode 为 Translucent时的Lighting Mode 
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME : 1;
	uint8 TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING : 1;

	uint8 EDITOR_PRIMITIVE_MATERIAL : 1;

	uint8 MATERIAL_FULLY_ROUGH : 1;

	uint8 MATERIALBLENDING_SOLID : 1;
	uint8 MATERIALBLENDING_MASKED : 1;
	uint8 MATERIALBLENDING_ALPHACOMPOSITE : 1;
	uint8 MATERIALBLENDING_TRANSLUCENT : 1;
	uint8 MATERIALBLENDING_ADDITIVE : 1;
	uint8 MATERIALBLENDING_MODULATE : 1;
	uint8 MATERIALBLENDING_ALPHAHOLDOUT : 1;

// Blend Mode
	uint8 SUBSTRATE_BLENDING_OPAQUE : 1;
	uint8 SUBSTRATE_BLENDING_MASKED : 1;
	uint8 SUBSTRATE_BLENDING_TRANSLUCENT_GREYTRANSMITTANCE : 1;
	uint8 SUBSTRATE_BLENDING_TRANSLUCENT_COLOREDTRANSMITTANCE : 1;
	uint8 SUBSTRATE_BLENDING_COLOREDTRANSMITTANCEONLY : 1;
	uint8 SUBSTRATE_BLENDING_ALPHAHOLDOUT : 1;

	uint8 USES_EMISSIVE_COLOR : 1;
	
	uint8 REFRACTION_USE_INDEX_OF_REFRACTION : 1;
	uint8 REFRACTION_USE_PIXEL_NORMAL_OFFSET : 1;
	uint8 REFRACTION_USE_2D_OFFSET : 1;

//其他属性 :
	uint8 USE_DITHERED_LOD_TRANSITION_FROM_MATERIAL : 1;
	uint8 MATERIAL_TWOSIDED : 1; //双面显示 .
	uint8 MATERIAL_ISTHINSURFACE : 1;
	uint8 MATERIAL_TANGENTSPACENORMAL : 1;
	uint8 GENERATE_SPHERICAL_PARTICLE_NORMALS : 1;
	uint8 MATERIAL_USE_PREINTEGRATED_GF : 1;
	uint8 MATERIAL_HQ_FORWARD_REFLECTIONS : 1;
	uint8 MATERIAL_PLANAR_FORWARD_REFLECTIONS : 1;
	uint8 MATERIAL_NONMETAL : 1;
	uint8 MATERIAL_USE_LM_DIRECTIONALITY : 1;
	uint8 MATERIAL_INJECT_EMISSIVE_INTO_LPV : 1;
	uint8 MATERIAL_SSR : 1; //屏幕反射:对应Screen Space Refections
	uint8 MATERIAL_CONTACT_SHADOWS : 1;
	uint8 MATERIAL_BLOCK_GI : 1;
	uint8 MATERIAL_DITHER_OPACITY_MASK : 1;
	uint8 MATERIAL_NORMAL_CURVATURE_TO_ROUGHNESS : 1;
	uint8 MATERIAL_ALLOW_NEGATIVE_EMISSIVECOLOR : 1;
	uint8 MATERIAL_OUTPUT_OPACITY_AS_ALPHA : 1;
	uint8 TRANSLUCENT_SHADOW_WITH_MASKED_OPACITY : 1;

//材质作用域 Material Domain
	uint8 MATERIAL_DOMAIN_SURFACE : 1;
	uint8 MATERIAL_DOMAIN_DEFERREDDECAL : 1;
	uint8 MATERIAL_DOMAIN_LIGHTFUNCTION : 1;
	uint8 MATERIAL_DOMAIN_VOLUME : 1;
	uint8 MATERIAL_DOMAIN_POSTPROCESS : 1;
	uint8 MATERIAL_DOMAIN_UI : 1;
	uint8 MATERIAL_DOMAIN_VIRTUALTEXTURE : 1;

	uint8 USE_STENCIL_LOD_DITHER_DEFAULT : 1;

	uint8 MATERIALDOMAIN_SURFACE : 1;
	uint8 MATERIALDOMAIN_DEFERREDDECAL : 1;
	uint8 MATERIALDOMAIN_LIGHTFUNCTION : 1;
	uint8 MATERIALDOMAIN_POSTPROCESS : 1;
	uint8 MATERIALDOMAIN_UI : 1;

	uint8 OUT_BASECOLOR : 1;
	uint8 OUT_BASECOLOR_NORMAL_ROUGHNESS : 1;
	uint8 OUT_BASECOLOR_NORMAL_SPECULAR : 1;
	uint8 OUT_WORLDHEIGHT : 1;
	uint8 OUT_DISPLACEMENT : 1;

	uint8 SUBSTRATE_ENABLED : 1;
	uint8 MATERIAL_IS_SUBSTRATE : 1;

	uint8 PROJECT_OIT : 1;

	uint8 DUAL_SOURCE_COLOR_BLENDING_ENABLED : 1;

	uint8 IS_MATERIAL_SHADER : 1;
	//// end

	uint32 MATERIALDECALRESPONSEMASK;

	// new ones
	uint8 IS_VIRTUAL_TEXTURE_MATERIAL : 1;
	uint8 IS_DECAL : 1;
	uint8 IS_BASE_PASS : 1;
	uint8 COMPUTE_SHADED : 1;
	uint8 USES_WORLD_POSITION_OFFSET;
	uint32 DECAL_RENDERTARGET_COUNT;
	uint32 GBUFFER_LAYOUT;

	uint8 bAllowDevelopmentShaderCompile : 1;// = Material->GetAllowDevelopmentShaderCompile();

};
```

### 11.1 Shading Mode  :

**一. 宏的作用及其形式 :**

**1. 形式 :**

- `MATERIAL_SHADINGMODEL_` 后面添加相应的Shader Mode 名字 .  

**2. 作用 :**

- 输出布尔值 ,  如果 Shading Mode 使用相应的方法 ,  则返回 1 ,  否则返回 0 .

```c++
//shading Mode
	uint8 MATERIAL_SHADINGMODEL_DEFAULT_LIT : 1;
	uint8 MATERIAL_SHADINGMODEL_SUBSURFACE : 1;
	uint8 MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN : 1;
	uint8 MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE : 1;
	uint8 MATERIAL_SHADINGMODEL_CLEAR_COAT : 1;
	uint8 MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE : 1;
	uint8 MATERIAL_SHADINGMODEL_HAIR : 1;
	uint8 MATERIAL_SHADINGMODEL_CLOTH : 1;
	uint8 MATERIAL_SHADINGMODEL_EYE : 1;
	uint8 MATERIAL_SHADINGMODEL_SINGLELAYERWATER : 1;
	uint8 SINGLE_LAYER_WATER_SEPARATED_MAIN_LIGHT : 1;
	uint8 MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT : 1;
```


### 11.2 在 Translucency 半透明模式下所使用的 Lighting Mode

**一. 定义及其形式 :**

**1. 形式 :**

- `TRANSLUCENCY_LIGHTING_` + Lighting Mode 

**2. 作用 :**

- 如果Lighting Mode 为Material使用选项 ,  则返回1 ,  否则返回 0.

```c++
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_NONDIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_PERVERTEX_DIRECTIONAL : 1;
	uint8 TRANSLUCENCY_LIGHTING_SURFACE_LIGHTINGVOLUME : 1;
	uint8 TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING : 1;

```

### 11.3 Blend Mode

**一. 定义及其形式 :**

**1. 形式 :**

- `SUBSTRATE_BLENDING_` + Blend Mode ;

**2. 作用 :**

- 此宏代表Material 使用的Blend Mode .  返回布尔值 .
```c++
	uint8 SUBSTRATE_BLENDING_OPAQUE : 1;
	uint8 SUBSTRATE_BLENDING_MASKED : 1;
	uint8 SUBSTRATE_BLENDING_TRANSLUCENT_GREYTRANSMITTANCE : 1;
	uint8 SUBSTRATE_BLENDING_TRANSLUCENT_COLOREDTRANSMITTANCE : 1;
	uint8 SUBSTRATE_BLENDING_COLOREDTRANSMITTANCEONLY : 1;
	uint8 SUBSTRATE_BLENDING_ALPHAHOLDOUT : 1;

```


### 11.4 Material Domain

**一. 定义及其形式 :**

**1. 形式 :**

- `MATERIAL_DOMAIN_` + Material Domain

**2. 作用 :**

- 返回Material 的 Domain 属性 ,  返回布尔值 .
```c++
//材质作用域 Material Domain
	uint8 MATERIAL_DOMAIN_SURFACE : 1;
	uint8 MATERIAL_DOMAIN_DEFERREDDECAL : 1;
	uint8 MATERIAL_DOMAIN_LIGHTFUNCTION : 1;
	uint8 MATERIAL_DOMAIN_VOLUME : 1;
	uint8 MATERIAL_DOMAIN_POSTPROCESS : 1;
	uint8 MATERIAL_DOMAIN_UI : 1;
	uint8 MATERIAL_DOMAIN_VIRTUALTEXTURE : 1;
```

















































































