# 一.CPP基础语法

## 1 C++初识

### 1.1  第一个C++程序

编写一个C++程序总共分为4个步骤

* 创建项目
* `创建文件
* 编写代码
* 运行程序

#### 1.1.1 创建项目

​	Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开

![1541383178746](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541383178746.png)



![1541384366413](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541384366413.png)

#### 1.1.2 创建文件

右键源文件，选择添加->新建项

![1541383817248](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541383817248.png)

给C++文件起个名称，然后点击添加即可。

![1541384140042](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541384140042.png)



#### 1.1.3 编写代码

```c++
#include<iostream>
using namespace std;

int main() {

	cout << "Hello world" << endl;

	system("pause");

	return 0;
}
```

#### 1.1.4 运行程序

![1541384818688](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541384818688.png)













### 1.2 注释

**作用**：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码

**两种格式**

1. **单行注释**：`// 描述信息` 
   - 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==
2. **多行注释**： `/* 描述信息 */`
   - 通常放在一段代码的上方，==对该段代码做整体说明==

> 提示：编译器在编译代码时，会忽略注释的内容











### 1.3 变量

**作用**：给一段指定的内存空间起名，方便操作这段内存

**语法**：`数据类型 变量名 = 初始值;`

**示例：**

```C++
#include<iostream>
using namespace std;

int main() {

	//变量的定义
	//语法：数据类型  变量名 = 初始值

	int a = 10;

	cout << "a = " << a << endl;
	
	system("pause");

	return 0;
}
```



> 注意：C++在创建变量时，必须给变量一个初始值，否则会报错















### 1.4  常量

**作用**：用于记录程序中不可更改的数据

C++定义常量两种方式

1. **\#define** 宏常量： `#define 常量名 常量值`
   * ==通常在文件上方定义==，表示一个常量


2. **const**修饰的变量 `const 数据类型 常量名 = 常量值`
   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改



**示例：**

```C++
//1、宏常量
#define day 7

int main() {

	cout << "一周里总共有 " << day << " 天" << endl;
	//day = 8;  //报错，宏常量不可以修改

	//2、const修饰变量
	const int month = 12;
	cout << "一年里总共有 " << month << " 个月份" << endl;
	//month = 24; //报错，常量是不可以修改的
	
	
	system("pause");

	return 0;
}
```










### 1.5 关键字

**作用：**关键字是C++中预先保留的单词（标识符）

* **在定义变量或者常量时候，不要用关键字**



C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。`











### 1.6 标识符命名规则

**作用**：C++规定给标识符（变量、常量）命名时，有一套自己的规则

* 标识符不能是关键字
* 标识符只能由字母、数字、下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写

> 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读















## 2 数据类型

C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存

### 2.1 整型

**作用**：整型变量表示的是==整数类型==的数据

C++中能够表示整型的类型有以下几种方式，**区别在于所占内存空间不同**：

| **数据类型**        | **占用空间**                                    | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |













### 2.2 sizeof关键字

**作用：**利用sizeof关键字可以==统计数据类型所占内存大小==

**语法：** `sizeof( 数据类型 / 变量)`

**示例：**

```C++
int main() {

	cout << "short 类型所占内存空间为： " << sizeof(short) << endl;

	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;

	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;

	cout << "long long 类型所占内存空间为： " << sizeof(long long) << endl;

	system("pause");

	return 0;
}
```





> **整型结论**：==short < int <= long <= long long==















### 2.3 实型（浮点型）

**作用**：用于==表示小数==

浮点型变量分为两种：

1. 单精度float 
2. 双精度double

两者的**区别**在于表示的有效数字范围不同。

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

**示例：**

```C++
int main() {

	float f1 = 3.14f;
	double d1 = 3.14;

	cout << f1 << endl;
	cout << d1<< endl;

	cout << "float  sizeof = " << sizeof(f1) << endl;
	cout << "double sizeof = " << sizeof(d1) << endl;

	//科学计数法
	float f2 = 3e2; // 3 * 10 ^ 2 
	cout << "f2 = " << f2 << endl;

	float f3 = 3e-2;  // 3 * 0.1 ^ 2
	cout << "f3 = " << f3 << endl;

	system("pause");

	return 0;
}
```











### 2.4 字符型

**作用：**字符型变量用于显示单个字符

**语法：**`char ch = 'a';`



> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号

> 注意2：单引号内只能有一个字符，不可以是字符串



- C和C++中字符型变量只占用==1个字节==。
- 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元



示例：

```C++
int main() {
	
	char ch = 'a';
	cout << ch << endl;
	cout << sizeof(char) << endl;

	//ch = "abcde"; //错误，不可以用双引号
	//ch = 'abcde'; //错误，单引号内只能引用一个字符

	cout << (int)ch << endl;  //查看字符a对应的ASCII码
	ch = 97; //可以直接用ASCII给字符型变量赋值
	cout << ch << endl;

	system("pause");

	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。













### 2.5 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```C++
int main() {
	
	
	cout << "\\" << endl;
	cout << "\tHello" << endl;
	cout << "\n" << endl;

	system("pause");

	return 0;
}
```













### 2.6 字符串型

**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   
   	char str1[] = "hello world";
   	cout << str1 << endl;
       
   	system("pause");
   
   	return 0;
   }
   ```

> 注意：C风格的字符串要用双引号括起来

1. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   int main() {
   
   	string str = "hello world";
   	cout << str << endl;
   	
   	system("pause");
   
   	return 0;
   }
   ```

   

> 注意：C++风格字符串，需要加入头文件==#include\<string>==













### 2.7 布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```C++
int main() {

	bool flag = true;
	cout << flag << endl; // 1

	flag = false;
	cout << flag << endl; // 0

	cout << "size of bool = " << sizeof(bool) << endl; //1
	
	system("pause");

	return 0;
}
```















### 2.8 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** `cin >> 变量 `

示例：

```C++
int main(){

	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << a << endl;

	//浮点型输入
	double d = 0;
	cout << "请输入浮点型变量：" << endl;
	cin >> d;
	cout << d << endl;

	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << ch << endl;

	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << str << endl;

	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量：" << endl;
	cin >> flag;
	cout << flag << endl;
	system("pause");
	return EXIT_SUCCESS;
}
```













## 3 运算符

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |

### 3.1 算术运算符

**作用**：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
//加减乘除
int main() {

	int a1 = 10;
	int b1 = 3;

	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除结果依然是整数

	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl; 

	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; //报错，除数不可以为0


	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.25;
	cout << d1 / d2 << endl;

	system("pause");

	return 0;
}
```

> 总结：在除法运算中，除数不能为0





**示例2：**

```C++
//取模
int main() {

	int a1 = 10;
	int b1 = 3;

	cout << 10 % 3 << endl;

	int a2 = 10;
	int b2 = 20;

	cout << a2 % b2 << endl;

	int a3 = 10;
	int b3 = 0;

	//cout << a3 % b3 << endl; //取模运算时，除数也不能为0

	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;

	//cout << d1 % d2 << endl;

	system("pause");

	return 0;
}

```

> 总结：只有整型变量可以进行取模运算



**示例3：**

```C++
//递增
int main() {

	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11

	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11

	//区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << b2 << endl;

	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << b3 << endl;

	system("pause");

	return 0;
}

```



> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反









### 3.2 赋值运算符

**作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |



**示例：**

```C++
int main() {

	//赋值运算符

	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;

	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl;

	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;

	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;

	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;

	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;

	system("pause");

	return 0;
}
```









### 3.3 比较运算符

**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {

	int a = 10;
	int b = 20;

	cout << (a == b) << endl; // 0 

	cout << (a != b) << endl; // 1

	cout << (a > b) << endl; // 0

	cout << (a < b) << endl; // 1

	cout << (a >= b) << endl; // 0

	cout << (a <= b) << endl; // 1
	
	system("pause");

	return 0;
}
```



> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 













### 3.4 逻辑运算符

**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {

	int a = 10;

	cout << !a << endl; // 0

	cout << !!a << endl; // 1

	system("pause");

	return 0;
}
```

> 总结： 真变假，假变真





**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {

	int a = 10;
	int b = 10;

	cout << (a && b) << endl;// 1

	a = 10;
	b = 0;

	cout << (a && b) << endl;// 0 

	a = 0;
	b = 0;

	cout << (a && b) << endl;// 0

	system("pause");

	return 0;
}

```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==







**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {

	int a = 10;
	int b = 10;

	cout << (a || b) << endl;// 1

	a = 10;
	b = 0;

	cout << (a || b) << endl;// 1 

	a = 0;
	b = 0;

	cout << (a || b) << endl;// 0

	system("pause");

	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==

















## 4 程序流程结构

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码



### 4.1 选择结构

#### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句

  

1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![img](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\clip_image002.png)

   示例：

   ```C++
   int main() {
   
   	//选择结构-单行if语句
   	//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   
   	int score = 0;
   	cout << "请输入一个分数：" << endl;
   	cin >> score;
   
   	cout << "您输入的分数为： " << score << endl;
   
   	//if语句
   	//注意事项，在if判断语句后面，不要加分号
   	if (score > 600)
   	{
   		cout << "我考上了一本大学！！！" << endl;
   	}
   
   	system("pause");
   
   	return 0;
   }
   ```

   


> 注意：if条件表达式后不要加分号







2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

![img](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\clip_image002-1541662519170.png)



示例：

```C++
int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else
	{
		cout << "我未考上一本大学" << endl;
	}

	system("pause");

	return 0;
}
```











3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

![img](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\clip_image002-1541662566808.png)







示例：

```C++
	int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}

	system("pause");

	return 0;
}
```









**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断



案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。



**示例：**

```c++
int main() {

	int score = 0;

	cout << "请输入考试分数：" << endl;

	cin >> score;

	if (score > 600)
	{
		cout << "我考上了一本大学" << endl;
		if (score > 700)
		{
			cout << "我考上了北大" << endl;
		}
		else if (score > 650)
		{
			cout << "我考上了清华" << endl;
		}
		else
		{
			cout << "我考上了人大" << endl;
		}
		
	}
	else if (score > 500)
	{
		cout << "我考上了二本大学" << endl;
	}
	else if (score > 400)
	{
		cout << "我考上了三本大学" << endl;
	}
	else
	{
		cout << "我未考上本科" << endl;
	}

	system("pause");

	return 0;
}
```







**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![三只小猪](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\三只小猪.jpg)









#### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {

	int a = 10;
	int b = 20;
	int c = 0;

	c = a > b ? a : b;
	cout << "c = " << c << endl;

	//C++中三目运算符返回的是变量,可以继续赋值

	(a > b ? a : b) = 100;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰









#### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch(表达式)

{

	case 结果1：执行语句;break;

	case 结果2：执行语句;break;

	...

	default:执行语句;break;

}

```







**示例：**

```C++
int main() {

	//请给电影评分 
	//10 ~ 9   经典   
	// 8 ~ 7   非常好
	// 6 ~ 5   一般
	// 5分以下 烂片

	int score = 0;
	cout << "请给电影打分" << endl;
	cin >> score;

	switch (score)
	{
	case 10:
	case 9:
		cout << "经典" << endl;
		break;
	case 8:
		cout << "非常好" << endl;
		break;
	case 7:
	case 6:
		cout << "一般" << endl;
		break;
	default:
		cout << "烂片" << endl;
		break;
	}

	system("pause");

	return 0;
}
```



> 注意1：switch语句中表达式类型只能是整型或者字符型

> 注意2：case里如果没有break，那么程序会一直向下执行

> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间















### 4.2 循环结构

#### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![img](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\clip_image002-1541668640382.png)







**示例：**

```C++
int main() {

	int num = 0;
	while (num < 10)
	{
		cout << "num = " << num << endl;
		num++;
	}
	
	system("pause");

	return 0;
}
```



> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环









**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。



![猜数字](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\猜数字.jpg)

















#### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![img](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\clip_image002-1541671163478.png)



**示例：**

```C++
int main() {

	int num = 0;

	do
	{
		cout << num << endl;
		num++;

	} while (num < 10);
	
	
	system("pause");

	return 0;
}
```



> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件













**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数





















#### 4.2.3 for循环语句

**作用：** 满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`



**示例：**

```C++
int main() {

	for (int i = 0; i < 10; i++)
	{
		cout << i << endl;
	}
	
	system("pause");

	return 0;
}
```







**详解：**

![1541673704101](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541673704101.png)



> 注意：for循环中的表达式，要用分号进行分隔

> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用











**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![timg](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\timg.gif)













#### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![1541676003486](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541676003486.png)











**示例：**

```C++
int main() {

	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			cout << "*" << " ";
		}
		cout << endl;
	}

	system("pause");

	return 0;
}
```













**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![0006018857256120_b](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\0006018857256120_b.jpg)





### 4.3 跳转语句

#### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句



**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;

	int num = 0;

	cin >> num;

	switch (num)
	{
	case 1:
		cout << "您选择的是普通难度" << endl;
		break;
	case 2:
		cout << "您选择的是中等难度" << endl;
		break;
	case 3:
		cout << "您选择的是困难难度" << endl;
		break;
	}

	system("pause");

	return 0;
}
```



**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++)
	{
		if (i == 5)
		{
			break; //跳出循环语句
		}
		cout << i << endl;
	}

	system("pause");

	return 0;
}
```



**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 5)
			{
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	system("pause");

	return 0;
}
```















#### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

**示例：**

```C++
int main() {

	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)
		{
			continue;
		}
		cout << i << endl;
	}
	
	system("pause");

	return 0;
}
```



> 注意：continue并没有使整个循环终止，而break会跳出循环











#### 4.3.3 goto语句

**作用：**可以无条件跳转语句



**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置



**示例：**

```C++
int main() {

	cout << "1" << endl;

	goto FLAG;

	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;

	FLAG:

	cout << "5" << endl;
	
	system("pause");

	return 0;
}
```



> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱













## 5 数组

### 5.1 概述

所谓数组，就是一个集合，里面存放了相同类型的数据元素



**特点1：**数组中的每个==数据元素都是相同的数据类型==

**特点2：**数组是由==连续的内存==位置组成的













![1541748375356](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541748375356.png)













### 5.2 一维数组

#### 5.2.1 一维数组定义方式

一维数组定义的三种方式：

1. ` 数据类型  数组名[ 数组长度 ]; `
2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`
3. `数据类型  数组名[ ] = { 值1，值2 ...};`



示例

```C++
int main() {

	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];

	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;

	//利用下标输出
	cout << score[0] << endl;
	cout << score[1] << endl;
	cout << score[2] << endl;


	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	
	//逐个输出
	//cout << score2[0] << endl;
	//cout << score2[1] << endl;

	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i < 10; i++)
	{
		cout << score2[i] << endl;
	}

	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

	for (int i = 0; i < 10; i++)
	{
		cout << score3[i] << endl;
	}

	system("pause");

	return 0;
}
```



> 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名

> 总结2：数组中下标是从0开始索引









#### 5.2.2 一维数组数组名

一维数组名称的**用途**：

1. 可以统计整个数组在内存中的长度
2. 可以获取数组在内存中的首地址





**示例：**

```C++
int main() {

	//数组名用途
	//1、可以获取整个数组占用内存空间大小
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;
	cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;
	cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;

	//2、可以通过数组名获取到数组首地址
	cout << "数组首地址为： " << (int)arr << endl;
	cout << "数组中第一个元素地址为： " << (int)&arr[0] << endl;
	cout << "数组中第二个元素地址为： " << (int)&arr[1] << endl;

	//arr = 100; 错误，数组名是常量，因此不可以赋值


	system("pause");

	return 0;
}
```



> 注意：数组名是常量，不可以赋值

> 总结1：直接打印数组名，可以查看数组所占内存的首地址

>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小











**练习案例1**：五只小猪称体重

**案例描述：**

在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};

找出并打印最重的小猪体重。









**练习案例2：**数组元素逆置

**案例描述：**请声明一个5个元素的数组，并且将元素逆置.

(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);

















#### 5.2.3 冒泡排序

**作用：** 最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
3. 重复以上的步骤，每次比较次数-1，直到不需要比较

![1541905327273](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541905327273.png)

**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

```C++
int main() {

	int arr[9] = { 4,2,8,0,5,7,1,3,9 };

	for (int i = 0; i < 9 - 1; i++)
	{
		for (int j = 0; j < 9 - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}

	for (int i = 0; i < 9; i++)
	{
		cout << arr[i] << endl;
	}
    
	system("pause");

	return 0;
}
```









### 5.3 二维数组

二维数组就是在一维数组上，多加一个维度。

![1541905559138](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第1阶段C++ 匠心之作 从0到1入门资料\学习C++不再难资料\C++基础入门讲义\assets\1541905559138.png)

#### 5.3.1 二维数组定义方式

二维数组定义的四种方式：

1. ` 数据类型  数组名[ 行数 ][ 列数 ]; `
2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`
4. ` 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`



> 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==

示例：

```C++
int main() {

	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;

	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			cout << arr[i][j] << " ";
		}
		cout << endl;
	}

	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 

	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
	
	system("pause");

	return 0;
}
```



> 总结：在定义二维数组时，如果初始化了数据，可以省略行数













#### 5.3.2 二维数组数组名



* 查看二维数组所占内存空间
* 获取二维数组首地址





**示例：**

```C++
int main() {

	//二维数组数组名
	int arr[2][3] =
	{
		{1,2,3},
		{4,5,6}
	};

	cout << "二维数组大小： " << sizeof(arr) << endl;
	cout << "二维数组一行大小： " << sizeof(arr[0]) << endl;
	cout << "二维数组元素大小： " << sizeof(arr[0][0]) << endl;

	cout << "二维数组行数： " << sizeof(arr) / sizeof(arr[0]) << endl;
	cout << "二维数组列数： " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;

	//地址
	cout << "二维数组首地址：" << arr << endl;
	cout << "二维数组第一行地址：" << arr[0] << endl;
	cout << "二维数组第二行地址：" << arr[1] << endl;

	cout << "二维数组第一个元素地址：" << &arr[0][0] << endl;
	cout << "二维数组第二个元素地址：" << &arr[0][1] << endl;

	system("pause");

	return 0;
}
```



> 总结1：二维数组名就是这个数组的首地址

> 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小













#### **5.3.3 二维数组应用案例**

**考试成绩统计：**

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**

|      | 语文 | 数学 | 英语 |
| ---- | ---- | ---- | ---- |
| 张三 | 100  | 100  | 100  |
| 李四 | 90   | 50   | 100  |
| 王五 | 60   | 70   | 80   |





**参考答案：**

```C++
int main() {

	int scores[3][3] =
	{
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};

	string names[3] = { "张三","李四","王五" };

	for (int i = 0; i < 3; i++)
	{
		int sum = 0;
		for (int j = 0; j < 3; j++)
		{
			sum += scores[i][j];
		}
		cout << names[i] << "同学总成绩为： " << sum << endl;
	}

	system("pause");

	return 0;
}
```



---

#### 5.3.4 数组之间的拷贝

**作用: 将一个数组的所有值直接拷贝到新的数组值里**

**语法:**

* `std::copy(std::begin(arr), std::end(arr), std::begin(newArr)); ` 

**解释: **

* `begin()` 返回数组首地址, `end()` 返回数组末尾地址, `begin`输入被更改的数组









## 6 函数

### 6.1 概述

**作用：**将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

### 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型 

2、函数名

3、参数表列

4、函数体语句 

5、return 表达式

**语法：** 

```C++
返回值类型 函数名 （参数列表）
{

       函数体语句

       return表达式

}
```



* 返回值类型 ：一个函数可以返回一个值。在函数定义中
* 函数名：给函数起个名称
* 参数列表：使用该函数时，传入的数据
* 函数体语句：花括号内的代码，函数内需要执行的语句
* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据





**示例：**定义一个加法函数，实现两个数相加

```C++
//函数定义
int add(int num1, int num2)
{
	int sum = num1 + num2;
	return sum;
}
```











### 6.3 函数的调用

**功能：**使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
{
	int sum = num1 + num2;
	return sum;
}

int main() {

	int a = 10;
	int b = 10;
	//调用add函数
	int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
	cout << "sum = " << sum << endl;

	a = 100;
	b = 100;

	sum = add(a, b);
	cout << "sum = " << sum << endl;

	system("pause");

	return 0;
}
```

> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参









### 6.4 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生，并不会影响实参==



**示例：**

```C++
void swap(int num1, int num2)
{
	cout << "交换前：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;

	int temp = num1;
	num1 = num2;
	num2 = temp;

	cout << "交换后：" << endl;
	cout << "num1 = " << num1 << endl;
	cout << "num2 = " << num2 << endl;

	//return ; 当函数声明时候，不需要返回值，可以不写return
}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	cout << "mian中的 a = " << a << endl;
	cout << "mian中的 b = " << b << endl;

	system("pause");

	return 0;
}
```



> 总结： 值传递时，形参是修饰不了实参的









### **6.5 函数的常见样式**

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

**示例：**

```C++
//函数常见样式
//1、 无参无返
void test01()
{
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout << "this is test01" << endl;
	//test01(); 函数调用
}

//2、 有参无返
void test02(int a)
{
	cout << "this is test02" << endl;
	cout << "a = " << a << endl;
}

//3、无参有返
int test03()
{
	cout << "this is test03 " << endl;
	return 10;
}

//4、有参有返
int test04(int a, int b)
{
	cout << "this is test04 " << endl;
	int sum = a + b;
	return sum;
}
```











### 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。



*  函数的**声明可以多次**，但是函数的**定义只能有一次**



**示例：**

```C++
//声明可以多次，定义只能一次
//声明
int max(int a, int b);
int max(int a, int b);
//定义
int max(int a, int b)
{
	return a > b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout << max(a, b) << endl;

	system("pause");

	return 0;
}
```











### 6.7 函数的分文件编写

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

```C++
//swap.h文件
#include<iostream>
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);

```

```C++
//swap.cpp文件
#include "swap.h"

void swap(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
}
```

```C++
//main函数文件
#include "swap.h"
int main() {

	int a = 100;
	int b = 200;
	swap(a, b);

	system("pause");

	return 0;
}

```













## 7 指针

### 7.1 指针的基本概念

**指针的作用：** 可以通过指针间接访问内存



* 内存编号是从0开始记录的，一般用十六进制数字表示

* 可以利用指针变量保存地址

  

### 7.2 指针变量的定义和使用

指针变量定义语法： `数据类型 * 变量名；`

**示例：**

```C++
int main() {

	//1、指针的定义
	int a = 10; //定义整型变量a
	
	//指针定义语法： 数据类型 * 变量名 ;
	int * p;

	//指针变量赋值
	p = &a; //指针指向变量a的地址
	cout << &a << endl; //打印数据a的地址
	cout << p << endl;  //打印指针变量p

	//2、指针的使用
	//通过*操作指针变量指向的内存
	cout << "*p = " << *p << endl;

	system("pause");

	return 0;
}
```



指针变量和普通变量的区别

* 普通变量存放的是数据,指针变量存放的是地址
* 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用



> 总结1： 我们可以通过 & 符号 获取变量的地址

> 总结2：利用指针可以记录地址

> 总结3：对指针变量解引用，可以操作指针指向的内存











### 7.3 指针所占内存空间



提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？



**示例：**

```C++
int main() {

	int a = 10;

	int * p;
	p = &a; //指针指向数据a的地址

	cout << *p << endl; //* 解引用
	cout << sizeof(p) << endl;
	cout << sizeof(char *) << endl;
	cout << sizeof(float *) << endl;
	cout << sizeof(double *) << endl;

	system("pause");

	return 0;
}
```



> 总结：所有指针类型在32位操作系统下是4个字节











### 7.4 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的



**示例1：空指针**

```C++
int main() {

	//指针变量p指向内存地址编号为0的空间
	int * p = NULL;

	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
	cout << *p << endl;

	system("pause");

	return 0;
}
```















**野指针**：指针变量指向非法的内存空间

**示例2：野指针**

```C++
int main() {

	//指针变量p指向内存地址编号为0x1100的空间
	int * p = (int *)0x1100;

	//访问野指针报错 
	cout << *p << endl;

	system("pause");

	return 0;
}
```





> 总结：空指针和野指针都不是我们申请的空间，因此不要访问。









### 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量




**示例：**


```c++
int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误

	system("pause");

	return 0;
}
```



> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量









### 7.6 指针和数组

**作用：**利用指针访问数组中元素

**示例：**

```C++
int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

	int * p = arr;  //指向数组的指针

	cout << "第一个元素： " << arr[0] << endl;
	cout << "指针访问第一个元素： " << *p << endl;

	for (int i = 0; i < 10; i++)
	{
		//利用指针遍历数组
		cout << *p << endl;
		p++;
	}

	system("pause");

	return 0;
}
```











### 7.7 指针和函数

**作用：**利用指针作函数参数，可以修改实参的值



**示例：**

```C++
//值传递
void swap1(int a ,int b)
{
	int temp = a;
	a = b; 
	b = temp;
}
//地址传递
void swap2(int * p1, int *p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
	swap1(a, b); // 值传递不会改变实参

	swap2(&a, &b); //地址传递会改变实参

	cout << "a = " << a << endl;

	cout << "b = " << b << endl;

	system("pause");

	return 0;
}
```



> 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递













### 7.8 指针、数组、函数

**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序

例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };



**示例：**

```c++
//冒泡排序函数
void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//打印数组函数
void printArray(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << endl;
	}
}

int main() {

	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);

	bubbleSort(arr, len);

	printArray(arr, len);

	system("pause");

	return 0;
}
```



> 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针









## 8 结构体

### 8.1 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型



### 8.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
* 定义结构体时顺便创建变量

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}stu3; //结构体变量创建方式3 


int main() {

	//结构体变量创建方式1
	struct student stu1; //struct 关键字可以省略

	stu1.name = "张三";
	stu1.age = 18;
	stu1.score = 100;
	
	cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;

	//结构体变量创建方式2
	struct student stu2 = { "李四",19,60 };

	cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;


	stu3.name = "王五";
	stu3.age = 18;
	stu3.score = 80;
	

	cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;

	system("pause");

	return 0;
}
```



> 总结1：定义结构体时的关键字是struct，不可省略

> 总结2：创建结构体变量时，关键字struct可以省略

> 总结3：结构体变量利用操作符 ''.''  访问成员









### 8.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**` struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`

**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
}

int main() {
	
	//结构体数组
	struct student arr[3]=
	{
		{"张三",18,80 },
		{"李四",19,60 },
		{"王五",20,70 }
	};

	for (int i = 0; i < 3; i++)
	{
		cout << "姓名：" << arr[i].name << " 年龄：" << arr[i].age << " 分数：" << arr[i].score << endl;
	}

	system("pause");

	return 0;
}
```

---

### 8.4 结构体指针

**作用：**通过指针访问结构体中的成员



* 利用操作符 `-> `可以通过结构体指针访问结构体属性



**示例：**

```C++
//结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};


int main() {
	
	struct student stu = { "张三",18,100, };
	
	struct student * p = &stu;
	
	p->score = 80; //指针通过 -> 操作符可以访问成员

	cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;
	
	system("pause");

	return 0;
}
```



> 总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员
>
> * 结构体指针是作用在指针上, 因此不能直接作用在类上.













### 8.5 结构体嵌套结构体

**作用：** 结构体中的成员可以是另一个结构体

**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct teacher
{
    //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct student stu; //子结构体 学生
};


int main() {

	struct teacher t1;
	t1.id = 10000;
	t1.name = "老王";
	t1.age = 40;

	t1.stu.name = "张三";
	t1.stu.age = 18;
	t1.stu.score = 100;

	cout << "教师 职工编号： " << t1.id << " 姓名： " << t1.name << " 年龄： " << t1.age << endl;
	
	cout << "辅导学员 姓名： " << t1.stu.name << " 年龄：" << t1.stu.age << " 考试分数： " << t1.stu.score << endl;

	system("pause");

	return 0;
}
```



**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题









### 8.6 结构体做函数参数 

**作用：**将结构体作为参数向函数中传递

传递方式有两种：

* 值传递
* 地址传递

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(student stu )
{
	stu.age = 28;
	cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
}

//地址传递
void printStudent2(student *stu)
{
	stu->age = 28;
	cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;
}

int main() {

	student stu = { "张三",18,100};
	//值传递
	printStudent(stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;

	cout << endl;

	//地址传递
	printStudent2(&stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;

	system("pause");

	return 0;
}
```

> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递







### 8.7 结构体中 const使用场景

**作用：**用const来防止误操作

**示例：**

```C++
//学生结构体定义
struct student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//const使用场景
void printStudent(const student *stu) //加const防止函数体中的误操作
{
	//stu->age = 100; //操作失败，因为加了const修饰
	cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;

}

int main() {

	student stu = { "张三",18,100 };

	printStudent(&stu);

	system("pause");

	return 0;
}
```









### 8.8 结构体案例

#### 8.8.1 案例1

**案例描述：**

学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下

设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员

学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值

最终打印出老师数据以及老师所带的学生数据。



**示例：**

```C++
struct Student
{
	string name;
	int score;
};
struct Teacher
{
	string name;
	Student sArray[5];
};

void allocateSpace(Teacher tArray[] , int len)
{
	string tName = "教师";
	string sName = "学生";
	string nameSeed = "ABCDE";
	for (int i = 0; i < len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j < 5; j++)
		{
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}

void printTeachers(Teacher tArray[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << tArray[i].name << endl;
		for (int j = 0; j < 5; j++)
		{
			cout << "\t姓名：" << tArray[i].sArray[j].name << " 分数：" << tArray[i].sArray[j].score << endl;
		}
	}
}

int main() {

	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>

	Teacher tArray[3]; //老师数组

	int len = sizeof(tArray) / sizeof(Teacher);

	allocateSpace(tArray, len); //创建数据

	printTeachers(tArray, len); //打印数据
	
	system("pause");

	return 0;
}
```









#### 8.8.2 案例2

**案例描述：**

设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。

通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。



五名英雄信息如下：

```C++
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
```









**示例：**

```C++
//英雄结构体
struct hero
{
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(hero arr[] , int len)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - 1 - i; j++)
		{
			if (arr[j].age > arr[j + 1].age)
			{
				hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << "姓名： " << arr[i].name << " 性别： " << arr[i].sex << " 年龄： " << arr[i].age << endl;
	}
}

int main() {

	struct hero arr[5] =
	{
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
	};

	int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

	bubbleSort(arr, len); //排序

	printHeros(arr, len); //打印

	system("pause");

	return 0;
}
```

---

## 9. 枚举

**概念 :**

* 拥有多种选择的布尔型(被限制范围的数值)0.. 且选择类型由自己定义. 
* 使用枚举定义多种常量, 增加程序的可读性. 
* 枚举本质上是一个结构体, 如`bool`型 有 `true == 0`; `flase == 1`; 枚举也是同理, 可以定义`字符串1 = 0` `字符串2 = 1` 等等如上.

### 9.1 枚举的定义

**语法 :**

* `enum 枚举名{常量1, 常量2, 常量3, 常量4}` 

**一. 解释 :**

* 这些常量 本质是从0 开始的 依次排列的 整数.

```c++
enum SHAPE
{
	zero,	// 0
	one,	// 1
	two,	// 2
	three,	// 3
	four = 6,	//可以手动指定底层整数类型为什么
};

int main()
{
	enum SHAPE test1= one;
	std::cout << test1 << endl;	//输出整数 1
}
```

---

### 9.2 枚举的定义与使用

**一. 语法:**

* `enum 枚举名 变量名;`
* `eunm 枚举名 变量名 = 类别;` 

**二. 解释 :**

* 给变量赋初始值

---

### 9.3 强类型枚举

**一. 语法 :**

* 定义: `enum class 枚举名 {};`
* 使用: `enum 枚举名 test1= 枚举名::one;`

**二. 解释 :**

* 强制避免命名冲突, 因此在赋初始值时需要强制加上作用域.
* 不支持隐式转换枚举型为整数型, 因此要需要直接转换法;

**三. 强枚举类型支持手动指定底层类型 :**

* 语法: `enum class 枚举名: 数据类型 {};`

```c++
enum class SHAPE: char 
{
	zero = 'fuck',	// 0
	one,	// 1
	two,	// 2
	three,	// 3
	four = 6,	//4
};

int main()
{
    enum SHAPE test1= SHAPE::one;
	std::cout << int(test1) << endl;
}
```

**注意 :**

* 指定类型为char 后, 没有手动赋予默认值的, 仍然会以整数类型存在, 规则为: ASCLL码表对应字母 +1
* 虽然可以指定数据类型, 但是打印出来仍然是 int



---

## 10. 编译预处理

* 在编译代码时, 编译器是经历了一系列的处理, 以hello world 程序距离, 主要为四个流程:
  * 1.[预处理源文件] 首先编写完"hello.cpp" 经过预处理处理后, 得到`hello.cpp.ii`文件;
  * 2.[编译预处理之后的文件] 进行编译, 获得汇编文件`hello.s` 汇编文件也是文本文件;
  * 3.[汇编文件汇编器处理] 获得`hello.o` 二进制文件, 此二进制文件为可重定位的二进制文件, 非可执行的程序文件;
  * 4.[链接其他程序] 跟函数库, `#incloud`等其他文件链接, 获得可执行文件;

### 10.1 宏指令

**一. 解释 :**

* 宏分为: 有参宏与无参宏;
* 宏名需要符合操作符的规范;
* 宏定义可以使用已经被定义过的宏名;
* 宏扩展时, 仅对宏进行简单的替换, 不做计算; 如定义`#define test 3+3` 不会计算3+3等于什么, 只会把`test` 替换为`3+3` 
* 宏定义的作用域只在当前文件里, 不会影响其他文件.
* 自己定义宏时尽量不要使用下划线, 避免冲突

**二. c++系统预定义的宏 :**

**一. 形式 :**

* 使用一个或者两个下划线开头和结尾.
* 关于更多的系统预订宏, 可以自行查阅文档

```c++
_DATE_ //当前日期
_TIME_	//当前时间
_TIMESTAMP_	//当前文件的最后修改日期及时间
_FILE_	//当前文件名
_LINE_	//当前行号
```



#### 10.1.1 无参宏

**一. 语法 :**

* `#define 宏名 宏的值` 
* 这个值无论是什么数据类型,均会被当成字符串处理.

**二. 解释:**

* 宏的本质是文本替换, 但是如果宏的名字在字符串里, 则不会被替换
* 宏一但定义, 则在编写程序时, 被直接文本替换为定义数值.

```c++
#define test 10;

int main()
{
	int num;
	num = test;	//会被文本替换为30

	cout << num << "test" << endl;	//宏出现在字符串里面不会被替换
}
```

**这是预处理之后的文件 :**

```c++
#define test 10;

int main()
{
	int num;
	num = 10;	//会被文本替换为30

	cout << num << "test" << endl;	//宏出现在字符串里面不会被替换
}
```

---

#### 10.1.2 有参宏

**一. 语法 :**

* `#define 宏名(参数列表) 函数主体`
* 定义有参宏时, 不用声明返回值.

**二. 解释 :**

* 参数列表里的宏字符 在程序员输入之后, 会被原封不动的替换到函数主体里.
* 在传参时, 如果传的是一个表达式, 则可以使用`()` 括起来, 这样会优先程序执行步骤

```c++
#define test(r) 5*r 
#define test2(j) 5*(j) 
int main()
{
	int i1 = 1;
	int i2 = test(i1 + 2);	//单纯的替换, 不做计算.
    int i3 = test2(i1 + 2);
    

	cout << i2 << endl;
}
```

**处理之后的文件 :**

```c++
#define test(r) 5*r 

int main()
{
	int i1 = 1;
	int i2 =5*i1+2;	
    int i3 = 5*(i1 + 2);	//加上括号更规范.

	cout << i2 << endl;
}
```

**三. 使用须知 :**

* 有参宏跟函数是有区别的:
  * 不用声明函数返回值
  * 参数列表不用声明参数类型
  * 宏调用不对参数做计算,只做简单的替换
* 宏可以调用已经声明过的宏;

---

#### 10.1.3  `#undef` 取消定义宏

**语法 :**

* `#undef 宏名`
* 取消定义一个宏

```c++
#define test1
#undef test1 //宏被取消定义
```

---

### 10.2 文件包含指令

**一. 语法:**

* `#include <文件名>` / `#include "文件名"`
* 在使用此指令后, 编译后会把文件内容全部原封不动的贴到此位置
* 使用尖括号和双引号的区别: 使用尖括号, 系统优先去系统在编译器预定义的文件夹去找. 如果使用双引号, 则取当前目录下遍历所有文件夹去找, 如果找不到, 则取编译器预定义的文件里去找.

**二. 使用须知 :**

* 系统的头文件一般在c盘, 具体依据IDE程序不同而定.
* 可以包含`.h .cpp`等

---

### 10.3 条件编译指令

**一. 形式 :**

* `#ifdef<宏名>`	如果宏被定义了, 执行
* `#ifndef<宏名>`      如果宏没被定义, 执行
* `#if<常量表达式>`   后面跟条件, 如果条件成立, 执行.配合`#else #endif` 使用



* `#elif` 如果前面为假, 条件为真, 执行以下语句
* `#else` 如果均为假, 执行以下语句
* `#endif` 结尾必须写.

**二. 解释 :**

* 如果宏存在, 则预处理阶段, 宏中间的代码存在, 如果宏不存在, 预处理阶段宏中间的代码会消失.
* 必须使用`#endif`结尾.

```c++
#define DEBUG

int main()
{
	int a = 10;

#ifdef DEBUG
	cout << a << endl;
#endif	//必须使用#endif结束

	cout << "a" << endl;	//如果没有定义,则直接执行此处.

}
```

预编译后

```c++
#define DEBUG

int main()
{
	int a = 10;

	cout << a << endl;

	cout << "a" << endl;	//如果没有定义,则直接执行此处.
}

```

---

### 10.4 条件编译指令的使用场景

* 在引用头文件时, 防止重复定义. 

```c++
#ifndef A_H	//如果没定义宏, 则执行以下. 保证只会定义一次
#define A_H
int a = 10;
void test01()
{
    
}

#endif
```

---

### 10.5 `#error` 报错指令

**一. 作用 :**

* 让预处理发出错误消息, 包含指令中的文本, 让编译过程中断	

**二. 使用场景 :**

```c++
#if __STD_CERSION__ != 201112L
#error NotC11	//#error 后面跟文本
```

**使用须知 :**

* `#error` 处于报错状态, 这是正常现象.

---

### 10.6 `#line` 指令

**一. 作用 :**

* 改变行号
* 更改文件名

**二. 语法 :**

* `#line 行号`
* `#line "文件名"`



# 二.CPP核心编程

本阶段主要针对CPP面向对象编程技术的详细讲解，探讨CPP中的核心和精髓。

## 1. 内存分区模型

**梗概 :**

* CPP程序在执行时，将内存大方向划分为4个区域：
  * **代码区：**存放函数体的二进制代码，由操作系统进行管理的。（写的所有代码和中文注释都存放于代码区中。）
  * **全局区：**存放全局变量和静态变量以及常量。
  * **栈区：**由编译器自动分配释放，存放函数的参数值，局部变量等.（由编译器管理他的生存与死亡。）
  * **堆区：**由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

**内存四区意义：**

* 不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。

### 1.1 **代码区与全局区**

**一.过程：**代码先转换为二进制，再存放进代码区中。（代码区与全局区都是程序运行前划分的两个区域。程序运行之后，才会出现栈区与堆区。）

**1.1程序运行前：**

​    在程序编译后，生成了EXE（双击可运行）可执行程序。未执行该程序之前，分为两个区域：

* 1.代码区: （通常存放在硬盘里，当程序执行时，代码会被加载到内存中。）
  * 存放CPU执行的机器指令。
  * 代码区是共享的，共享的目的为对于频繁执行的程序，只需要在内存中有一份代码即可。
  * 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令。
*  **2.全局区：**
  * 全局变量和静态变量、常量存放于此
  * 全局区还包括了常量区，字符串常量和其他常量（const修饰变量）也存放于此。
  * 该区域的数据在程序结束后由操作系统释放。



**二.变量：**

* 局部变量：只要是定义在函数体内的所有变量都是局部变量。包括main函数.
* 静态变量：加上关键字 static .

* 常量：

  * 字符串常量：双引号引起来的。

  * const修饰变量：全局变量：const修饰。

    ​                            局部变量：

**三.使用须知：**

* 注意：不在全局区中的变量：局部变量、局部常量（const修饰）。只要是局部的都不在全局区中。

在全局区的：全局变量，静态变量（static）关键字、常量（字符床，const修饰。）

**四：总结：**

1) CPP在程序运行前只有全局区与代码区。

2) 全局区仅存放全局变量，静态变量、常量

3) 常量区存放被const限制的全局变量、字符床常量（双引号里的字符串）。

---

### 1.2 栈区

**概念：**

* 栈区存放局部变量、形式参数。

**解释 : **

* 由编译器自动分配释放，存放函数的参数值，局部变量等。

**使用须知 :**

* 由于栈区存放的是局部变量。也就是在函数里定义的变量。所以当函数运行完毕之后，栈区会自动释放局部变量的内存，避免造成资源浪费。此逻辑会对地址传递函数造成影响。因为内存释放后，函数内内存地址数据未知。仍然使用原地址会导致指针为野指针。
* 不要解释局部变量的地址，因为栈区开辟的数据由编译器自动释放。

---

### 1.3 **堆区与new操作符**

**概念：**

* 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。在CPP中，主要利用new在堆区开辟内存。

**语法：**

* `new 数据类型（数值）`

**解释：**

1) 此语法只返回地址编号，因此只能用指针接收。无参数名。

2) 指针本质也是放在栈区上的一个局部变量，但指针的地址指向的数据放在堆区。

3) 由于指针本身也是局部变量。在函数运行完毕之后，指针本身也会消失。因此，使用时请使用有效内存空间存储此指针。只有如此，才能获得内存位置，并访问与修改相应内存中的内容。

4) new函数本质为在栈区开辟了一块新内存，括号里为该内存具体数值。整体返回一串地址。使用时可以解释地址来进行读写操作。

---

### 1.4 **new操作符（精解）**

**作用：**CPP中利用new操作符在堆区开辟数据

#### 1.4.1 new操作符开辟变量

**属性：**堆区开辟的数据，由程序员手动开辟，手动释放，释放符delete

**语法：**new 数据类型 （数值）；

**解释：**利用new创建的数据，会返回该数据对应的类型的指针地址。



#### 1.4.2 new操作符开辟数组

**作用：**在堆区手动创建数组。

**语法：**new 数据类型【元素数量】；

**解释：**整体返回堆区数组地址；

---



### 1.5 delete 操作符

**作用：**手动释放new关键字在堆区开辟的内存。

**语法：**delete 指针地址；

**一.使用须知：**

1）使用delete手动释放内存之后，就无法再访问相应内存。如果硬要访问的话就会出错。

**二.delete释放数组：**

语法：delete【】 指针地址；（释放数组时要加上中括号。）

## 2.引用

### 2.1 **引用的基本使用**

**作用：**给变量起别名

**语法：**数据类型 &别名 = 原名；

**解释：**变量的本质由以下几点构成：1.由4块内存构成的一个内存区；2.内存区里的数值；3.内存的名称以及内存的地址。操作内存的话使用变量名称，当然，变量名称就可以有不止一个。给变量起别名的技术就叫做：引用。

**举例：**

 ```c++
 int a  = 0;
 int &aTextur  = b;
 cout << b;
 
 //输出 0
 ```



**一.使用须知：**

1)引用必须要初始化；引用必须要上来就告诉他，等于什么变量？

2）引用一旦初始化后，就不可以更改。如引用已经别名为a，就不可以更改为b

---

### 2.2 **引用做函数参数**

**作用:** 函数传参时,可以利用引用的技术让形式参数修饰实际参数.

**优点:** 可以简化指针修改实际参数.

**语法:** `void test(int &a, int &b){} `

**解释:**

​    1)CPP中,函数的值传递目前有三种: 值传递, 地址传递, 引用传递. 其中, 值传递是单独在内存中开辟一块内存, 地址传递与引用传递均属于修改同地址的内存. 引用传递

​    2)理解语法时,int &a 可以理解为 int &a = (原名) 函数输入的变量. 函数括号里整体是赋值的操作,不过是给省略了.

```c++
void test(int a,int b){
    
}
int main(){
    test(1 , 2); // 可以理解为: int a = 1; int b = 2;在编写代码时,把=去掉,引用函数即视为赋值.
}
```

---

### 2.3 **引用做函数返回值**

**作用:** 引用是可以作为函数的返回值存在的.

**注意:** 

* 不要返回局部变量的引用
* 函数的调用可以作为左值. 进行修改操作. 同名称变量可以被相互识别. 因此在使用引用时,只需要确保进程中定义过相同内存变量(此定义不限制任何别名,只要是相同变量即可.)

---

### 2.4 **引用的本质**

**本质:** 引用的本质在CPP内部是一个指针常量.

**Eg:** ` int &ref = b; == int* const ref = &b; ref == *ref;`

**解释:**1)由于指针常量无法修改地址, 因此可以视为引用.

---



### 2.6常量引用

***作用***  :常量引用主要使用场景为修饰形式参数, 防止误操作.

***语法***  :在函数参数列表中, 可以加const修饰形参, 防止形参改变实参.

**Eg1)**

```c++
int main(){
    int a = 10;
    int & ref = 10;  //错误:引用必须引用合法内存,如栈区或堆区上的内存.
    
    //加上const 之后,编译器自动把代码翻译为:int temp = 10; const int & ref = temp;
	const int & ref = 10;
    
}
```

**一.使用须知**

* 引用加入const之后, 变为只读状态, 禁止修改.



#### 2.6.1: 常量引用的常见使用场景

```c++
//打印数据函数
void showValue(const int &val){	//经过const 限制后,在使用值传递的前提下,可有效防止变量被修改的误操作.
    cout<<"val ="<< val << endl;
}

int main(){
    int a = 100;
    
    showValue(a);
}
```

**一.使用须知**

* 定义变量时可防止误操作.

---

---

## 3.函数提高

### 3.1函数的默认值

**解释** :在CPP中. 函数的形参列表中的形参是可以后默认值的.

> 语法:  ==返回值类型  函数名  (参数 = 默认值) {  }==

Eg1):

```c++

int func(int a = 0,int b = 0,int c = 0){
    retuen a+b+c;
}

int main(){
    
    cout<<func(10,20,32);
    
    system("pause");
}
```

**一.使用须知**

在创建函数时, 参数类型可以 赋值 一个默认值. 当无参数传入时, `参数 = 默认值`; 当有参数传入时, `参数 = (传入的参数 , 传入的参数 , 传入的参数)`

**二.注意事项**

* 如果某个位置已经有了默认参数,那么从这个位置==从左向右==,都必须有默认值.

Eg2)

```c++
int func(int a = 0, int b,int c){}	//错误:由于int a已经被默认赋值,因此,从int a从左到右都必须有默认参数.

int func(int a ,int b = 0, int c = 0){}   //正确
```

* 声明与实现只能一个有默认参数.

```c++
int func(int a = 10,int b = 10);

int func(int a = 10,int b = 10){	//错误:函数被重定义,需要去掉使用函数时的默认值
    return a+b;
}

int func(int a,int b){	//正确
    return a+b;
}
```

* 因此, 如果定义函数时有默认值,实现函数时就不要有默认值, 否则会出现二义性错误.

  ---

  ---

### 3.2函数占位参数

**作用**: CPP中函数的形参列表里可以有占位参数, 用来做占位, 调用函数时必须填补该位置.

> 语法:==返回值类型 函数名 (数据类型){ }==

```c++
void func(int a,int){	//只输入数据类型就代表占位.
    cout<<"hello world"<<endl;
    
}

int main(){
    func(10, 10);	//直接传一个相同数据类型的整形即可
}
```

**一.使用须知**

* 由于函数体内仅占位,没有被定义. 现在目前用不到, 后面的课程会使用.
* 占位参数 还可以有默认参数

```c++
void func(int a, int = 10){	//	占位参数也可以有默认数值.
    cout<<"Hello World";
    
}
```

---

---

### 3.3函数重载

**作用** :函数名可以相同,提高复用性. 就是利用相同函数名 但是不同的函数参数类型来调用函数名相同的不同函数

**函数重载的满足条件:**

* 同一个作用域下(如目前写的函数均为全局函数,因此在一个作用域下.)
* 函数名称相同
* 函数参数类型不同 或个数不同 或顺序不同

**注意** :函数的返回值不可以作为函数重载的条件.

```c++
void func(string a = "函数func(string a)的调用"){
    cout<<a;
}

void func(int a){
    cout << "函数func(int a)的调用";
}

int main(){
    func(10);//调用函数参数类型为整数的函数
    func("string")//调用函数类型为字符串的函数
    
    system("pause");
    return 0;
}
```

**解释** :函数的重载会根据调用函数时输入的不同的数据类型来调用相应的函数.

**一.使用须知** :

* 函数的返回值类型不可以作为函数重载的条件. 原因为:

```c++
void func(int a){
    cout<<a;
}

int func(int a){
    cout<<a;
}

main (){
    func(1);	//此时会发生错误,因为函数的返回值类型不能作为函数重载的条件
}
```

**二.注意事项** :

* 在引用作为重载条件时,加const与不加const可以作为重载条件.

```c++
void func(int &a){
    cout<<"func(int &a)的调用";
}

void func(const int &a){
    cout<<"func(const int &a)的调用";
}

int main(){
    int a = 10;
    func(a); //此函数会调用func(int &a),因为a是变量,变量的定义为可读写,而const int &a为不可					写,因此会调用第一个函数.
    
    func(10);//此函数会调用func(const int &a),因为10为常量,常量时不可写可读的.因此会调用					Func(const int & a).
}
```

* 函数重载碰见默认参数 (函数重载尽量不要给默认参数. )

```c++
void func(int a , int b = 10){
    cout<<"func(int a , int b = 10)";
}

void func(int a){
    cout<<"func(int a)";
}

int main(){
    func(10);	//错误:当函数重载碰见默认参数,会出现二义性,要尽量避免这种情况.
    func(10,20);	//正确:覆盖默认参数,不会出现二义性.
}
```

---

### 3.4  函数指针

* 在CPP里, 函数代码存放在代码区中. 因此,函数也拥有自己的地址. 

**函数取址语法 :**

* `&函数名` 返回一串地址
* 函数名本身就是 一串地址,与数组同理.

**函数类型 :**

* 函数有自己的类型, 为 `函数返回值 (函数参数列表)` 因此在定义函数指针时, 指针类型需要为函数类型;

**定义函数指针语法 :**

* `函数返回值 (*指针名) (函数参数列表) = 函数名没括号;` 
* 注意: 指针名必须放在中间, 这是规定; 小括号不能省去, 必须加上小括号;
* 定义函数指针时, 可以省略形参名字

```c++
void test01(int a)
{
    cout<<a<<endl;
}

int main()
{
    void (*p)(int a)= test01;	//定义指针与指针地址
    void (*p)(int) = test01;	//省略形参名字
}
```

---

### 3.5 函数指针的调用

**作用 :**

* 使用函数指调用函数, ==函数调用的本质是` 函数地址 (参数列表)` ===

**语法 :**

* `(&函数指针)(参数列表)` 
* `(函数指针)(参数列表)`
* 二者都一样, 常用第二个

```c++
int test01(int a)
{
	return a;
}

int main()
{
	int(*p)(int) = test01;
	cout << (p)(1) << endl;//注意,括号不可以省略;
}
```

---

### 3.6 函数做参数

**作用 :**

* 将一个函数做参数传递使用

**语法 :**

* `函数返回值类型 函数名 (参数列表一,参数列表二, 相应函数的函数返回值类型(函数指针)(相应函数参数列表))`



```c++


void test01(int a, int b, int(*p)(int))//小括号不可省略
{
	cout << a << b << (p)(110) << endl;
}

int test02(int a = 0)
{
	return a;
}

int main()
{
	test01(1,2,test02);  //在`main`函数里使用`teat01`时,只需要把函数名传入即可.
}
```

**解释 :**

* 本质就是 在函数初始化时 , 把指针`p` 初始化成 `test02`; 在此函数里, 使用`p` 即代表着使用函数`test02`
* 在`main`函数里使用`teat01`时,只需要把函数名传入即可.

---

## 4.类和对象

**一.基础认知:**

* **CPP面向对象的三大特性为:** 封装, 继承, 多态.
* CPP认为万事万物皆为对象, 对象上有其属性和行为.
* 具有相同属性的对象, 我们称之为类. 人属于人类, 车属于车类.

### 4.1封装

**封装的意义** :

* 将属性与行为作为一个整体, 表现生活中的事物.
* 降属性和行为加以权限控制.

**封装的意义一 :** 

​	在设计类的时候, 属性和行为写在一起,表现事物.

> **语法** : class 类名 { 访问权限: 属性 / 行为 } ; 



Eg1): 设计一个圆类, 求圆的周长.

```c++
//圆周率(圆周长的公式: 2*PI*半径)
const double PI = 3.14;//声明全局常量

class Ciecle{
    //访问权限
public:		//公共权限
    
    //属性
    int m_r;	//半径
    
    //行为
    double calculateZC(){	//行为函数
        return 2*PI*m_r;
    }
};

int main() {

    Ciecle c1;	//实例化:通过圆类 创建名字为c1的(对象)

    c1.m_r = 10;    //给圆的属性进行赋值

    cout << "圆的周长为:  " << c1.calculateZC() << endl;		//调用类的函数.
}
```

**解释** :

* 类形式上: 属性为变量, 行为为函数.
* 局部变量向下兼容

示例2):设计一个学生类, 属性有姓名与学号, 可以给姓名和学号赋值,可以显示学生的姓名与学号.

```c++
class student	//设计学生类
{
public:	//公共权限
    
    string m_name;	//属性
    int m_id;
    
    void showstudent()	//行为
    {
        cout<<"name's:"<<m_name<<"ID's:"<<m_id<<endl;
    }
};

int main(){
    student s1;
    s1.m_name = "old wang";
    s1.m_id = 1;
    
    s1.showstudent();
}
```

**二.使用须知:** 

* 属性不仅仅可以在main函数里手动赋值,也可以在行为里赋值.

```c++
class student	//设计学生类
{
public:	//公共权限
    
    string m_name;	//属性
    int m_id;
    
    void showstudent()	//行为
    {
        cout<<"name's:"<<m_name<<"ID's:"<<m_id<<endl;
    }
    
    void setName(string name){	//在行为里赋值
        n_name = name;
    }
};

int main(){
    student s1;
    s1.srtname("old wang");		//使用函数进行赋值
    s1.m_id = 1;
    
    s1.showstudent();
}
```

* 类中的属性和行为,我们将其统一称之为: 成员
* 属性: 成员属性 成员变量
* 行为: 成员函数 成员方法

#### 4.1.1 封装的访问权限

**意义** : 类在设计时,可以把属性和行为放在不同的权限下,加以控制.

**访问权限可以分为三种** :

* public	公共权限:  成员  类内可以访问  类外可以访问

* protected 保护权限:  成员  类内可以访问  类外不可以访问
* private      私有权限:  成员  类内可以访问  类外不可以访问

**一.使用须知** :

1) protected 保护权限为儿子可以访问父亲中的保护内容
2) private 私有权限为儿子也不可以访问父亲的私有内容

Eg1):

```c++
class Person {
public:		//公共权限
	string m_Name;

protected:	//保护权限
	string m_Car;

private:	//私有权限
	int m_Password;	//银行卡密码

public:
	void func() {
		m_Name = "old li";
		m_Car = "small car";
		m_Password = 123456;
	}
};

int main() {
	Person p1;
	p1.m_Name = "old li";
	p1.m_car = "big car";	//错误;保护权限,类外不可访问.
	m_Password = 123;	//错误;私有权限,类外不可访问
}
```



**二.解释** :

* 类内为定义类时的大括号里面.

---

---

#### 4.1.2 struct和class的区别

**解释** : 在CPP中,struct 和 class唯一的区别就在于 默认的访问权限不同.

**区别: ** 

* struct 默认权限为公共
* class 默认权限为私有

```c++
class C1 {
	int m_A;	//默认权限	私有
};

struct C2 {
	int m_A;	//默认权限	公有
};

int main() {
	C1 c1;
	c1.m_A = 100;	//错误:class的默认权限为私有.

	C2 c2;
	c2.m_A = 100;	//无错,struct的默认权限为公共.
    
    system("pause");
}
```

---

---

#### 4.1.3 自控制类中成员属性读写权限

**解释 :** 

* 将所有成员属性设置为私有,可以自己控制读写权限
* 对于写权限可以检测数据的有效性.

**一.使用须知:**

* 具体操作过程就是使用公有的方法对私有的属性进行控制.

**Eg1):**

```c++
class Person {

public:

	void setName(string name) {	//	公有方法设置姓名	写
		m_name = name;

	}

	string getName() {
		return m_name;	//公有方法获取姓名

	}

	int setAge() {	//获取,读
		return m_Age;

	}

	void setIdol(string idol) {		//只写
		m_Idol = idol;
	}
private:
	string m_name;	//姓名	可读可写
   0 .
	int m_Age = 18;	//年龄	只读

	string m_Idol;	//偶像	只写
};

int main() {
	Person p1;

	p1.m_name = 100;	//错误,私有权限无法访问

	cout << p1.getName();	//正确,使用公有的方法访问私有权限下的私有成员属性
    
	system("pause");
}
```

---

***练习:设计点和圆的关系案例***

```c++
class Point {
public:
	void setX(int x) {
		m_X = x;
	}

	int getX() {
		return m_X;
	}

	void setY(int y) {
		m_Y = y;
	}

	int getY() {
		return m_Y;
	}

private:
	int m_X;
	int m_Y;
};

class Circle {
public:

	void setR(int r) {
		m_R = r;
	}

	int getR() {
		return m_R;
	}

	void setCenter(Point center) {
		center = m_Center;
	}

	Point getCenter() {
		return m_Center;
	}
private:
	int m_R;

	Point m_Center;
};

void isInCircle(Circle &c,Point p) {

	//判断两点之间距离的平方
	int distance =
		(c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) +
		(c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());

	//计算半径的平方
	int rDistance = c.getR() * c.getR();

	//判断关系
	if (distance == rDistance) {
		cout << "点在圆上" << endl;
	}
	else if (distance > rDistance) {
		cout << "点在园外" << endl;
	}
	else
	{
		cout << "点在园内" << endl;
	}
}

int main() {
	Circle c;
	c.setR(10);
	Point center;
	center.setX(10);
	center.setY(0);
	c.setCenter(center);

	Point p;
	p.setX(10);
	p.setY(10);

	isInCircle(c, p);
}
```

**一. 案例核心:** 

* 在类中, 可以让另一个类作为本类中的成员.

#### 4.1.4 对象与类的分文件编写

**作用 : ** 可以令代码的结构更清晰

**一.操作流程 : **

* 创建一个新头文件(.h)与源文件( .cpp), 注意命名规范. 
* 在头文件前写:` #pragma once      #include <iostream>     using namespace std;`
* 在头文件里写类与**成员函数的声明**与**成员变量的声明**
* 在源文件中 需要先引用头文件: #include "头文件名.h"
* 源文件不需要再次声明类,使用补全函数即可.(由于在源文件里直接写的函数为全局函数,因此, 需要使用操作符" ::"来详细补充函数所在类.)
* 在`int main() {}`入口函数中,想要引用相应的函数,则需要引用头文件 `#include "头文件名.h"`

Eg1):

> 头文件 .

```c++
//头文件:
#pragma once
#include <iostream>
using namespace std;

class Point {
public:
	void setX(int x);

	int getX();

	void setY(int y);

	int getY();

private:
	int m_X;
	int m_Y;
};

```

> 源文件 .CPP

```c++
#include "point.h"
#include <iostream>     
using namespace std;

void Point::setX(int x) {
	m_X = x;
}

int Point::getX() {
	return m_X;
}

void Point::setY(int y) {
	m_Y = y;
}

int Point::getY() {
	return m_Y;
}
```

---

### 4.2 对象的初始化和清理

**作用 : **

* CPP中的面向对象来源于生活, 每个对象也都会有初始设置以及 对象销毁前的清理数据的设置.

---

#### 4.2.1 构造函数和析构函数

**作用 : **

* 构造函数存在与类里, 当创建类对象时, 会自动调用==一次==构造函数.

**意义 : **

* 对象的初始化和清理是像个非常重要的安全问题
  * 一个对象或者变量没有初始状态, 对其的使用后果是未知的;
  * 同样的使用完一个对象或变量, 没有及时清理, 也会造成一定的安全问题. 
* CPP利用了构造函数和析构函数解决上述问题, 这两个函数将会被编译器自动调用, 完成对象初始化和清理工作.  对象的初始化和清理工作是编译器强制要我们做的事情, 因此如果我们不提供析构函数, 编译器会提供编译器提供的构造函数和析构函数 是空实现.
  * 构造函数:主要作用在于创建对象时为对象的成员属性赋值, 构造函数由编译器自动调用, 无需手动调用
  * 析构函数: 主要作用在于对象销毁前系统自动调用, 执行一些清理工作.



**构造函数语法 : **

* `类名( ){ }`

1) 构造函数, 没有返回者也不用写void
2) 函数名称与类名相同
3) 构造函数==可以==有参数, 因此==可以==发生重载
4) 程序在调用对象时候会自动调用构造, 无需手动调用, 而且只会调用一次. 



**析构函数语法 :**

* `~类名( ){ }`

1) 构造函数, 没有返回者也不用写void
2) 函数名称与类名相同,在名称前加 ~
3) 构造函数==不可以==有参数, 因此==不可以==发生重载
4) 程序在对象销毁前会自动调用析构, 无需手动调用, 而且只会调用一次. 



**一.使用须知 :　**

* 当你构建类时没有使用构造函数, 编译器会自动写: `类名 () { }` 也就是空实现.
* 当你构建类时没有使用析构函数, 编译器会自动写: `~类名 () { }` 也就是空实现.
* 当函数内存空间释放时,才会使用销毁对象,才会使用析构函数.

```c++
class Person
{
public:
	// 构造函数
	Person()	//函数名与类名相同
	{
		cout << "构造函数的调用" << endl;
	}

	~Person() {
		cout << "析构函数调用" << endl;
	}
};

void test01() {
	Person p;	//在栈区的对象,test01执行完毕后, 会释放这个对象.
}
int main() {
	//test01();	//构造函数会在创建对象时自动被调用
	Person p;	//运行完 system("pause"); 后会调用析构函数

	system("pause");
}
```

---

#### 4.2.2 构造函数的分类及调用

**两种分类方式 : **

* 按参数分为 :　**有参构造**和无参构造(默认构造)

```c++
class Person {
public:
	Person() {
		cout << "无参构造函数";
	}
	Person(int a) {
		cout << "有参构造函数";
	}
};
```

* 按类型分为 ：**拷贝构造**和普通构造

```c++
class Person {
public:
	//拷贝构造函数
	Person(const Person &p ) {
		// 将传入的人身上的所有属性,拷贝到构造函数上
	}
};
```

**三种调用方法 : **

* 括号法

> `类名 对象名;`   默认调用默认构造与普通构造

```c++
Person p1;	//默认构造函数调用
person p2(10);	//默认调用有参构造函数
Person P3(p2);	//默认调用拷贝构造函数, 将p2的所有属性拷贝到P3上.
```

* 显示法

> `类名 对象名 = 类名( 参数 ); ` //调用有参构造

```c++
Person p2 = Person( 10 );	//调用类中的有参构造函数
Person p3 = Person( p2 );	//调用类中的拷贝构造

//解释:
Person(10);	是一个匿名对象, 若有等号, 等号左边为匿名函数的名字. 
```

* 隐式转换法

> `类名 对象名 = 参数;`	//相当于写了 Person p4 = Person(10);

```c++
Person p2 = 10;
```



**一.作用 : **

* 拷贝构造函数的作用为 将传入的同类对象身上的所有属性, 拷贝到本类对象上.

**二.使用须知 : **

* 默认构造函数调用时不要加: ( ).原因为加上括号之后,编译器会认为这是一个函数的声明.

* ==匿名对象==当前行执行结束后, 系统会立即会后掉匿名的对象.(匿名对象会先执行一遍匿名对象的类)

* 不要利用拷贝构造函数初始化匿名对象Eg1:

* ```c++
  Person (p3);	//编译器会认为Person (p3)  === Person p3;
  ```

---

#### 4.2.3 拷贝构造函数的调用时机

**三种情况 : **

* 使用一个已经创建完毕的对象来初始化一个新对象(常规方法)
* 值传递的方式给函数参数传值(把定义对象放在函数参数里, 通过值传递给定义对象输入一个其他对象)
* 用值方式来返回局部对象(把对象放进函数的输出值里)

**一.解释 : **

* 构造函数: 传回数据类型,调用参数构造函数; 传回对象, 调用拷贝构造函数.
* 定义对象时顺便调用构造函数

```c++
class Person {
public:
	Person() {
		cout << "Person默认构造函数调用" << endl;
	}

	Person(int age) {
		cout << "Person有参构造函数调用" << endl;
		m_age = age;
	}
	
	Person(const Person& p) {
		cout << "Person默认拷贝构造函数调用" << endl;
		m_age = p.m_age;
	}

	~Person() {
		cout << "Person析构函数调用" << endl;
	}

	int m_age = 0;
};

// 01. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {
	Person p1(20);
	Person p2(p1);

	cout << "p2的年龄为:  " << p2.m_age << endl;	//最常用的使用方式: 将其他对象类中的函数拷贝到本对象中的属性
}

//02.使用一个已经创建完毕的对象来初始化一个新对象
void doWork(Person p) {

}

void test02() {
	Person p;
	doWork(p);	//由于doWork() 传入一个对象; Person p = p(对象), 为隐式转换法; 又因为拷贝构造函数需要传入其他对象, 因此形成值传递的方式给函数参数传值
}

//03.值方式返回局部对象
Person doWork2() {
	Person p1;
	return p1;	//函数返回对象时,声明函数类型要写类名.
}
void test03() {
	Person p = doWork2();	//利用函数返回对象, 来调用拷贝构造函数.
}
int main() {
	test01();
	test02();
	test03();

	system("pause");
}

```

---

#### 4.2.4 构造函数调用规则

**默认情况下,CPP编译器至少给一个类添加3个属性:  **

1) 默认构造函数(无参, 函数体为空)
2) 默认析构函数(无参, 函数体为空)
3) 默认拷贝构造函数, 对属性进行值拷贝

**构造函数调用规则如下:**

1) 如果我们写了有参构造函数, 编译器就不再提供默认构造, 但依然提供拷贝构造. 因此,当你没有定义构造函数,且如果你定义了参数构造函数,在定义对象时也要给予参数. 否则会报错.
   1) 此拷贝构造函数为`Person(const & p){ 类属性变量 = p.类属性变量};`也就是就算你没写拷贝构造函数,你也可以传入一个同类对象以此来继承属性.这是编译器自带的.
2) 如果我们写了拷贝构造函数, 编译器就不再提供其他的普通构造函数了.

**一.总结: **

* 如果提供有参构造函数,则不提供默认构造函数;如果你提供拷贝构造函数, 编译器就不提供默认构造函数与有参构造函数了.

示例:

```c++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没00有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

---

#### 4.2.5 深拷贝与浅拷贝

**定义 : **

* 浅拷贝: 简单的赋值拷贝操作;
* 深拷贝: 在堆区重新申请空间，进行拷贝操作;

**解释 :**

* 浅拷贝会带来: 堆区的内存重复释放的错误.

**错误示范:**

```c++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a,int height) {
		age = a;
		m_Height = new int(height); //	堆区开辟内存
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		//析构代码, 将堆区开辟数据做操作释放
		if (m_Height != NULL) {
			delete m_Height;
			m_Height = NULL;
		}
		cout << "析构函数!" << endl;
	}
public:
	int age;
	int* m_Height;
};

void test01() {
	Person p1(18,160);	//整数调用有参构造函数

	cout << "p1的年龄有多大?" << p1.age<<"身高为: "<<*p1.m_Height<<endl;

	Person p2(p1);

	cout << "p2的年龄有多大?" << p2.age << "身高为: " << *p2.m_Height << endl;

}//由于指针指向同一个位置,而这两个类均为相同. 因此, 内存会被释放两次而发生错误.

int main() {
	test01();
}
```

* 为了防止此错误,需要自己实现拷贝构造函数 解决浅拷贝带来的问题.

```c++
Person(const Person &p){
    cout<<"拷贝构造函数的调用"<<endl;
    m_age = p.m_age;	//浅拷贝: 编译器的默认代码
    m_hight = p.m_hight;	//造成错误的代码    
    m_Height = new int(*p.Height)  ; 	//利用深拷贝解决浅拷贝的问题.
}
```

**解释: **

* 利用new函数 更改本对象指针的地址, 并开辟了新一块内存. 解决了重读清空的错误.
* 如果属性有在堆区开辟的, 一定要自己提供拷贝构造函数,防止浅拷贝带来的问题.

---

#### 4.2.6 初始化列表

**作用 :**

* CPP提供了初始化列标语法, 用来初始化属性

> 语法`构造函数(函数变量):属性1(值1),属性2(值2)...{}`

**传统意义的初始化值:**

```c++
class Person
{
public:

	//传统初始化的操作
	Person(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}

	int m_A;
	int m_B;
	int m_C;
};
```

**初始化列表:**

```c++
class Person
{
public:

	Person() :m_A(10), m_B(20), m_C(30)
	{

	}

	int m_A;
	int m_B;
	int m_C;
};	//无法更改的赋予初始值的操作
```

2):

```c++
class Person
{
public:

	Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c)
	{

	}

	int m_A;
	int m_B;
	int m_C;
};		//	可以灵活更改的初始化赋值操作
```

---

#### 4.2.7 类对象作为类成员

**作用 : **

* CPP类中的成员可以是另一个类的对象, 我们称该成员为 **对象成员**

Eg1) : 

```c++
class A {}
class B {
    A a;
}
```

**使用须知 :**

* 使用类对象作为类成员时, 先运行类成员的类的构造函数 , 然后是对象的构造函数. 
* 析构函数则与构造的顺序相反.先运行对象的析构函数 , 再运行类的析构
* 理解: 引用类对象做为类成员时 , 先运行类成员的类,然后对象类, 然后结束对象类 , 然后结束类成员类

Eg 1):

```c++
class phone
{
public:
	phone(string phoneName)
	{
		p_Name = phoneName;
	}

	//手机名称
	string p_Name;
};

class Person
{
public:

	Person(string Name, string nameofphone):Name(Name),Phone(nameofphone)	//Phone(nameofphone) 括号法调用有参构造函数
	{

	}
	//name
	string Name;
	//phone
	phone Phone;

};

void test01()	//当其他类的对象作为本类成员, 构造时候先构造类对象, 再构造自身.  
{
	Person p("old li", "Redmi");

	cout << p.Name << "拿着" << p.Phone.p_Name << endl;
}

int main()
{
	test01();
}
```

---

#### 4.2.8 静态成员

**作用 :**

* 静态成员就是在成员变量和成员函数前加上关键字static , 称为静态成员. 静态成员分为: 

  * 静态成员变量

    * 所有对象共享同一份数据  (这个数据内存中只有一份 , 谁改,谁访问之后就是改过的值 . )
    * 在编译阶段分配内存 (静态成员变量编译阶段就分配内存了. 创建在全局区 , )
    * 类内声明, 类外初始化 (必须要有一个初始值 否则无法正常使用)

  * ```c++
    // 如何类内声明, 类初始化?
    class Person
    {
    public:
    
    	static int m_A;	//所有对象都共享同一份数据 
    
    };
    
    int Person::m_A = 100;	//使用::对变量限制作用域.
    ```

    * 静态成员变量
      * 所有对象共享同一个函数
      * 静态成员函数只能访问静态成员变量

**定义语法 :**

> **静态成员函数定义语法 :** `static 变量名;`  
>
> **静态成员变量定义语法:** static 函数名 () {}

**一.静态成员的访问方式 :**

* 由于静态成员变量 不属于某个对象 , 所有对象都共享同一份数据. 因此静态成员变量有两种访问方式:

  * 1. 通过对象进行访问

       * `person p;   cout<<p. 静态变量名;`
2. 通过类名进行访问
   
   * `cout<<类名::静态变量名;`

**静态成员变量的访问权限 :**

* 私有权限
  * 类外无法直接访问 , 需要使用自控制函数进行修改 .
* 公共权限
  * 类外可以直接访问静态成员变量 .

---

**二.静态函数的访问方式 :**

* 直接通过对象访问
  * `类名 对象名;	静态函数名();`
* 直接通过类名访问
  * 类名 :: 静态函数名();

**静态函数的访问权限 :**

* 私有权限
  * 类外无法访问到私有静态成员函数

---

**三.使用须知:**

* 静态成员变量 不可以访问 非静态成员变量

```c++
class Person
{
public:

	//静态成员函数
	static void func()
	{
		m_A = 100;	//静态成员函数可以访问静态成员变量
		m_B = 100;	//错误:静态成员变量 不可以访问 非静态成员变量
		cout << "静态成员函数调用" << endl;
	}

	static int m_A;
	int m_B;
};
```

---

 ### 4.3 cpp对象模型和this指针

#### 4.3.1 成员变量与成员函数分开存储

**1.解释 :**

* 在CPP中, 类内的成员变量和成员函数分开存储, 只有非静态成员变量才属于类的对象上
* CPP编译器会给每个空对象也分配一个字节空间, 是为了区分空对象占内存的位置

```c++
class Person
{
	int a;	//在类的对象里
	static int b;	//静态成员变量 不属于类的对象上
	void func() {}	//非静态成员函数 不属于类的对象上

	static void func2() {}	//静态成员函数 不属于类的对象上
};
```

**2.解释 :**

* 只有非静态成员变量 属于类的对象上

---

#### 4.3.2 this 指针概念

**一.作用 :**

* 每一个非静态成员函数只会诞生一份函数示例 , 也就是多个同类对象会共用一块代码. 那这一块代码是如何区分哪那个对象调用自己的呢?
* 当形参和成员变量同名时 , 可以用this指针来区分.

**二. 意义**

* 首先,this指针指向对象的位置, 指向被调用的成员函数所属的对象. 也就是谁调用this, this就指向谁(对象)

**三. 使用须知 :**

* this指针不需要被定义, 直接使用即可;
* this指针是隐含每一个非静态成员函数内的一种阵阵

**四. this指针的用途 :**

* 当形参和成员变量同名时, 可使用this指针来区分;
* 因为this指针指向对象, 因此 *this 返回对象本身;(哪个对象调用他, 他就指向那个对象)

反面例子:

```c++
class Person
{
public:
	Person(int age)
	{
		age = age;	//编译器认为这三个age是同一个age , 与成员变量无关.
	}
	int age;
};
```

解决代码:

```c++
class Person
{
public:
	Person(int age)
	{
		this->age = age;	// 加 this-> 则指向调用他的对象, 也就是指向了对象里的属性, 因此可以和函数里的age做区分. 
	}
	int age;
};
```

* 返回对象本身用 *this

举例:

```c++
class Person
{
public:
	Person& PersonAddAge(Person& p)	//如果不加&引用 ,则返回一个新对象. 如果加引用 ,则返回对象本身
	{
		this->age += p.age;
		return *this; //this 指针指向p1(对象), *this 等价于 p1, Person&(函数返回值类型) 返回为对象的引用.
        
 // 如果直接返回对象(不返回引用), 在链式编程时会导致 PersonAddAge(Person &p = p1), 语法上没有错误, 但是会直接返回一个新对象, 因为他返回了新的p2, 可以理解为p2` ,不是原本的p2
}
	}
	int age;
};
void test(){
    Person p;
    p.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); // 链式编程思想
}
```

#### 4.3.3 空指针访问成员函数

**作用 :**

* CPP中空指针也是可以调用成员函数的, 但是也要注意有没有用到this指针.举例: 

* ```c++
  //空指针调用成员函数
  class Person
  {
  public:
  	void showClassName()
  	{
  		cout << "this is Person Class" << endl;
  	}
  
  	void showPersonAge()
  	{
  		cout << "age is " << age << endl;	/*使用了 成员属性age, 在CPP里, 成员属性的前面都默认加了 this->; 由于对象指针p为空指针(没有创建实际对象), 因此this->指针也指向了空的值. 因此,错误原因为 this指针为 空指针*/
  	}
  
  
  	int age;
  };
  
  void test01()
  {
  	Person* p = NULL;
  
  	p->showClassName();
  	p->showPersonAge();
  }
  
  int main()
  {
  	test01();
  }
  ```

* 解决方法为提高代码的健壮性

* ```c++
  //使用if语句判断this指针是否为空指针
  if (this == NULL)
  {
      return;
  }
  ```

#### 4.3.4 const修饰成员函数

**1. 常函数的定义 :**

* 成员函数后加const后我们称为这个函数为常函数;
* 常函数内不可以修改成员属性;
* 成员属性声明时加关键字mutable后, 在常函数中依然可以修改;

例子1)

```c++
//常函数
class Person
{
public:

	//1. this指针的本质 为指针常量 指针的指向是不可修改的
	//2. 也就是 Person * const this = p;
	void showPerson() const	
    //3. 当函数后面加const时, 编译器会理解为 const Person* const this = p; 指向与数据均不可修改. 因此成员函数后面加const, 本质修饰的this指针, 让指针指向的值也不可以修改.
	{
		A = 100;
	}

	mutable int A;//特殊变量,即使在常函数只,也可以修改这个值(注意加关键字mutable)
};

void test01()
{
	Person p;
	p.showPerson();
}
```



**2. 常对象 :**

* 声明对象前加const称改独享为常对象;
* 常对象只能调用常函数;

```c++
int main()
{
	const Person p;
	p.A = 100; //错误, 常对象无法修改常函数

	p.B = 100;	//正确, 可以修改mutable修饰的特殊变量
    p.func();    //错误, 常对象不可以调用常函数, 因为常函数有可能修改常函数.
}
```

---

### 4.4 有元

**定义 :**

* 在程序里, 有些私有属性 也想让类外特殊的一些函数或者类进行访问, 就需要用到有元的技术.

**语法 :**

* 有元的关键字为 friend

**有元的三种实现 :**

* 全局函数做有元
* 类做有元
* 类中的成员函数做有元

#### 4.4.1 全局函数做有元

 **1. 使用方法 :**

* 在使用类是, 写:`friend: 函数返回者 函数名 (函数参数);` 写在类里就可以

例子1):

```c++
class Building
{
	//goodGay全局函数是 Building的好朋友, 可以访问building中私有的成员
	friend void goodGay(Building* building);

public:

	Building()
	{
		SittingRoom = "客厅";

		BedRoom = "卧室";
	}

public:
	string SittingRoom;
private:
	string BedRoom;
};

void goodGay(Building *building)
{
	cout << "好基友的全局函数 正在访问: " << building->SittingRoom << endl;
	cout << "好基友的全局函数 正在访问: " << building->BedRoom << endl;
}

void test01()
{
	Building b;
	goodGay(&b);
}

int main()
{
	test01();
	system("pause");
}
```

#### 4.4.2 类做有元

**1. 作用 :**

* 引用A类的对象 可以访问 B类的对象 中的私有属性

**2. 语法 :**

* `friend 类名 class 类名;`

举例1):

```c++
class Building
{
	friend class GoodGay;
public:
	Building();

public:
	string SittingRoom;
private:
	string BedRoom;
};

Building::Building()
{
	SittingRoom = "客厅";

	BedRoom = "卧室";
}

class GoodGay
{
public:
	GoodGay()
	{
		this->b = new Building;
	}

	void visit()
	{
		cout << "好基友正在访问: " << b->SittingRoom << endl;
	}
		//参观函数 访问Building中的属性
	Building* b;
};

void test01()
{
	GoodGay g;
	g.visit();
}
int main()
{
	test01();
}
```

---

#### 4.4.3 成员函数做友元

**1. 语法 :**

* `friend 函数返回者 函数名;` (类成员的函数名, )

**2. 举例 ): **

```c++
class Building;
class GoodGay
{
public:
	GoodGay();
public:
	Building* b;

	void visit();	//让visit可以访问build中私有成员

	void visit2();
};

class Building
{
	friend void visit();
public:
	Building();
public:
	string SittingRoom;

private:
	string BedRoom;	//卧室
};

Building::Building()
{
	this->SittingRoom = "客厅";
	this->BedRoom = "卧室";
}

GoodGay::GoodGay()
{
	b = new Building;
}

void GoodGay::visit()
{
	cout << "visit 函数正在访问: " << b->SittingRoom << endl;
	cout << "visit 函数正在访问: " << b->BedRoom << endl;
}

void GoodGay::visit2()
{
	cout << "visit 函数正在访问 :" << b->SittingRoom << endl;
	cout << "visit 函数正在访问 :" << b->Bedroom << endl;
}

void test01()
{
	GoodGay g;
	g.visit();
	g.visit2();
}

int main()
{
	test01();
}
```

---

### 4.5 运算符重载

* 对已有运算符重新定义, 赋予其一种功能, 以适应不同的数据类型.

#### 4.5.1 加号运算符重载

**1. 作用 :**

* 实现两个自定义数据类型相加的运算

**2. 解释 :**

* 对于内置的数据类型, 编译器知道如何运算. 

**3.语法 :**

* operator+ 为运算函数名称, 底层原理为:

```c++
Person operator+(Person &p)
{
	Person temp;
	temp.A = this->A + p.A;
	temp.B = this->B + p.B;

	return temp;	//返回新的对象
}

//当你使用了编译器提供的函数名称, 
Person p3 = p1.operator+(p2);
//  等价于 
Person p3 = p1 + p2;//如果没有写运算符重载, 则会出现错误.
```

**解释 :**

* 通过成员函数重载 + 号;

**4. 通过全局函数重载运算符 :**

举例1 :

```c++
Person operator+ (Person& p1, Person& p2)
{
	Person temp;
	temp.A = p1.A + p2.A;
	temp.B = p1.B + p2.B;

	return temp;
}

//调用本质 :
Person p3 = operator+ (p1 , p2);	//运行本质为调用拷贝构造函数, 实行属性拷贝

//等价于
Person p3 = p1 + p2;
```

**5. 运算符重载也可以发生函数重载 :**

* 回顾: 函数重载为: 相同函数名称, 相同函数返回者, 用不同的函数参数来区分具体调用那个函数.

**作用 :**

* 提高函数的复用率. 

```c++
Person operator+ (p1 , p2) ;

Person operator+ (p1 , int a);

int main()
{
    Person p3 = p1 + 10;  //使用函数重载选择调用不同的运算符重载
}
```

**6. 使用须知 :**

* 对于内置的数据类型的表达式的运算符是不可以修改的;
* 不要滥用运算符重载; (相加就是想加, 相减就是想减等;)

#### 4.5.2 左移运算符重载

**作用 :**

* 可以输出自定义数据类型.

**使用场景 :**

```c++
int main()
{
	Peron p;
	p.A = 10;
	p.B = 15;

	cout << p << endl;    // 能否直接输出对象的属性?
}
```

**使用方法 :**

* 利用成员函数实现左移运算符:

* ```c++
  class Person
  {
  public:
      void operator<<(cout)
      {
          //一般不使用成员函数重载左移运算符, 因为调用形式为 p << cout;
      }
  public:
  
  	int A;
  	int B;
  };
  ```

* 全局函数重载左移运算符

* ```c++
  ostream& operator<< (ostream &cout , p)	//本质为 operator(cout , p), 简化为cout << p;
  {
     cout << p.A << p.B;
      return cout;
  }
  ```

* 

**cout 解释 :**

* cout 的本质是 ostream(标准输出流) 类的 对象, 而且此对象全局仅有一个.

**1.使用须知:**

* 由于cout<<为链式编程, 因此, 函数的返回者要返回cout对象的引用. 
* 左移运算符配合有元可以输出自定义数据类型.

#### 4.5.3 递增运算符重载

**作用 :**

* 通过重载递增运算符, 实现自己的整形数据;

**举例1 前置递增:**

```c++
class MyInteger
{
friend ostream & operator<<(ostream& cout, MyInteger& p);

public:
	MyInteger()
	{
		Num = 10;
	}

	//重载前置++运算符
	MyInteger& operator++()	//返回引用是为了一直对一个数据进行递增操作, 返回的是同一个对象
	{
		 Num++;
		 return *this;
	}
private:
	int Num = 0;
};

ostream& operator<<( ostream& cout, MyInteger& p)
{
	cout << p.Num;
	return cout;
}
void test01()
{
	MyInteger m1;

	cout << m1 << endl;
}

int main()
{
	test01();
}
```

举例与使用 后置递增函数:

```c++
void op//后置递增
MyInteger& operator++(int)	//int代表占位参数,用于区分前置与后置递增.注意,在CPP里仅承认int为后置递增的占位参数
{
	//1. 记录当时结果
	MyInteger temp = *this;

	//2. 递增
	Num++;

	//3. 最后将记录结果做返回操作.
	return temp;	//注意: 输出结果一样, 但输出的是temp.Num;
}
```

---

#### 4.5.4 赋值运算符重载

**解释 :**

* CPP编译器至少给一个类添加4个函数
  * 默认构造函数(无参, 函数体为空)
  * 默认析构函数(无参, 函数体为空)
  * 默认拷贝构造函数, 队属性进行值拷贝
  * 赋值运算符 operator= , 对属性进行值拷贝

EG:

```c++
class Person
{
public:
	Person(int age)
	{
		
		Age = new int(age);	//浅拷贝, 将指针的地址拷贝到指针中,本质是用同一块内存
	}

	Person& operator=(Person &p)
	{
		if (Age != NULL)
		{
			delete Age;
			Age = NULL;
		}
		else
		{
			Age = new int(*p.Age);	//深拷贝, 将指针解引用的值存到新开辟的堆区中.
		}

		return *this;
	}
	~Person()
	{
		if (Age != NULL)
		{
			delete Age;
			Age = NULL;
		}
	}
public:
	int* Age;
};

void test01()
{
	Person p1(18);

	Person p2(20);
	Person p3(25);

	p3 = p2 = p1;	//p3.operator(p2);
	cout << *(p1.Age);
	cout << *(p2.Age);
	cout << *(p3.Age);

	
}
int main()
{
	test01();
}
```



**使用须知:**

* 符号左边为函数参数第一个值, 符号右边为函数参数第二个值.

---

#### 4.5.5 关系运算符

**作用 :**

* 重载关系运算符, 可以让两个自定义类型对象对比操作

举例:

```c++
//关系运算符
class Person
{
public:
	Person(string name, int age)
	{
		this->Name = name;

		this->Age = age;
	}

	bool operator==(Person& p)
	{
		if (this->Name == p.Name && this->Age == p.Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
public:
	string Name;
	int Age;
};

void test01()
{
	Person p1("old li", 18);

	Person p2("old li", 18);

	if (p1 == p2)	//p1.operator==(Person &p);
	{
		cout << "p1和p2是相等的" << endl;
	}
}

int main()
{
	test01();
}
```

---

#### 4.5.6 函数调用运算符重载

**解释 :**

* 函数调用运算符 ( ) 也可以重载
* 由于重载后使用的方式非常像函数的调用, 因此称为仿函数
* 仿函数没有固定写法, 非常灵活

举例:

```c++
class MyPrint
{
public:

	//重载函数调用运算符
	void operator()(string test)
	{
		cout << test << endl;
	}

};

void test01()
{
	MyPrint m1;

	m1("hello world");	//m1.operator()("hello world");
}

int main()
{
	test01();
}
```

**使用须知 :**

* 函数重载没有固定的使用方法, 是灵活百变的.

**匿名函数对象 :**

* 语法 `对象名()(   ,   )`
* 直接使用函数对象进行函数调用运算符的调用.

---

### 4.6 继承

**定义:**

* 定义类时, 下级别的成员除了拥有上一级的共性, 还有自己的特性. 这个时候, 就可以使用继承的技术, 减少重复的代码.

#### 4.6.1 继承的基本语法

**作用 :**

* 将公共类的属性, 行为继承到新的类中

**语法 :**

* `class 子类名 :继承方式 父类`  (子类也被称为派生类 , 父类称为 基类)

**举例 1:**

```c++
class BasePage
{
public:
	void header()
	{
		cout << "首页 , 公开课 , 登录 , 注册" << endl;
	}

	void footer()
	{
		cout << "帮助中心, 交流合作, 站内地图" << endl;
	}

	void left()
	{
		cout << "Java , Python , CPP" << endl;
	}

};

class Java :public BasePage
{
public:
	void content()
	{
		cout << "Java学科视频" << endl;
	}
};
```

**解释 :**

* 继承下来的成员函数视为在本类中, 直接调用即可. 子类的成员: 从父类继承过来(表现共性), 与自己新增的(个性.
* 可以减少重复的代码

---

#### 4.6.2 继承方式

 **继承方式一共有三种 :**

* 公共继承
* 保护继承
* 私有继承

**不同继承方式的区别 :**

* private(私有权限): 父类中的私有权限下的内容 无论使用什么继承方式 均不可访问(继承). 当使用私有继承时, 父类中的公共权限与保护权限内容均转换为子类中的私有权限.
* public(公共权限): 父类中的公共权限 继承到子类中依然是公共权限; 父类中的保护权限 继承到子类中依然是保护权限.(以公共继承的方式继承 会继承父类的访问权限 注: 无法继承私有权限)
* protected(保护权限): 父类中的公共权限继承到子类后 转换为保护权限. 父类中的保护权限依然是保护权限.(私有权限依然无法被继承)

**举例 :**

```c++
class Base1
{
public:
	int A;

protected:
	int B;

private:
	int C;
};

class Son1 :public Base1	//公共继承
{
public:
	void func()
	{
		A = 1;	//父类中的公共权限成员 到子类中依然是公共权限
		B = 1;	//父类中的保护权限成员 到子类中依然是保护权限
		C = 1;	//错误, 父类中的私有权限成员 不可被继承
	}
};

class Son2 :protected Base1
{
public:
	void func()
	{
		A = 1;	//父类中公共成员到子类中变为保护权限
		B = 1;	//父类中保护成员到子类中依然是保护权限
		C = 1;	//错误, 私有权限成员 不可被继承
	}
};

class Son2 :private Base1
{
public:
	void func()
	{
		A = 1;	//父类中公共成员到子类中变为私有权限
		B = 1;	//父类中保护成员到子类中变为私有权限
		C = 1;	//错误, 私有权限成员 不可被继承
	}
};
```

---

#### 4.6.3 继承中的对象模型

**解释 :**

* 子类会继承父类中所有的非静态属性, 
* 父类中私有成员属性 是被编译器隐藏了,因此访问不到 . 但是确实被继承下去了. 
* 所以占用的内存一点都没少 

**利用开发人员工具查看对象模型 :**

* 跳转盘符  `盘符:`
* 跳转文件路径 `cd 具体路径下`
* 查看明明 `c1 /d1 reportSingleClassLayout类名 文件名`

---

#### 4.6.4 继承中的构造和析构函数运行顺序

**解释 :**

* 先运行 父类 的构造函数
* 再运行 子类 的构造函数
* 再运行 子类 的析构函数
* 最后运行 父类的 析构函数

**理解 :**

* 先运行父亲,再运行儿子. 儿子运行完毕之后, 父亲才结束运行.

---

#### 4.6.5 继承同名成员处理方式

* 当子类与父类出现同名的成员, 如何通过子类对象, 访问到子类或父类中同名的数据呢?

**解释 :**

* 访问子类同名成员, 直接访问即可
* 访问父类同名成员, 需要加作用域

**举例 :**

```c++
class Base
{
public:
	Base()
	{
		A = 100;
	}

	int A;
};

class Son :public Base
{
public:
	Son()
	{
		A = 200;
	}

	int A;	//同名成员属性
};

void test01()
{
	Son s;
	cout << s.A;	//访问子类属性, 直接访问即可

	cout << s.Base::A;	//访问父类对象, 需要加作用域.
}

int main()
{
	test01();
}
```

**使用须知 :**

* 如果子类中出现和福来同名的成员函数, 子类的同名成员函数会隐藏父类中所有的同名成员函数.因此无法直接使用函数重载来调用.
* 如果想访问父类中被隐藏的同名成员函数, 需要加作用域

---

 #### 4.6.6 继承同名静态成员处理方式

**解释 :**

* 静态成员和非静态成员出现同名, 处理方式一致;
* 访问子类同名成员 直接访问即可
* 访问父类同名成员 需要加作用域

**举例 :**

```c++
class Base
{
public:
	static int A;	
};

int Base::A = 100;

class Son :public Base
{
public:
	static int A;
};

int Son::A = 200;

void test01()	//同名静态成员函数
{
	Son s;
    //通过对象访问
	cout << s.A;	//Son下的静态变量
	cout << s.Base::A;	//Base下的静态变量

	//通过类名来访问
		
	cout << Son::A;	//直接使用作用域即可
	cout << Base::A;	//直接使用作用域即可

	//通过子类对象访问父类的作用域
	cout << Son::Base::A;	//Son类里的Base父类作用域下的A(静态变量)
}
```

**举例 (静态函数调用) :**

```c++
void test02()
{
	Son s;
	//1. 通过对象访问
	s.func();	//直接调用对象下的静态函数
	s.Base::func();	//父类下的静态函数

	//2.通过类名访问
	Son::func();
	Base::func();

	//3.子类访问父类的静态函数
	Son::Base::func();
}
```

---

#### 4.6.7 多继承语法

* CPP中允许一个类继承多个类

**语法 :**

* `class 子类:继承方式 父类1, 继承方式 父类2...`

**使用须知 :**

* 多继承可能会引起父类中有多个同名成员出现, 需要加作用域区分.
* CPP实际开发中不建议使用多继承

举例:

```c++
class Base1
{
public:
	Base1()
	{
		m_A = 100;
	}

	int m_A = 100;
};

class Base2
{
public:
	Base2()
	{
		m_B = 200;
	}

	int m_B;
};

class Son :public Base1, public Base2	//继承多个父类
{
public:
	Son()
	{
		m_C = 300;

	}

	int m_C;
};
```

**使用须知 :**

* 当两个父类中出现同名成员, 会出现二义性错误, 需要加上具体的作用域.

---

#### 4.6.8 菱形继承(近亲继承, 同基继承)

**概念 :**

* 两个子类继承同一个父类
* 又有某个子类同时继承这两个子类
* 这种继承被称为菱形继承, 或钻石继承

**菱形继承的问题 :**

* 羊继承了动物的数据, 驼也继承了动物的数据, 当羊驼使用数据时,会产生二义性.
* 羊驼继承自动物的数据继承了两份, 但这份数据我们只需要一份.

Eg1 :

```c++
class Animal {
public:
	int Age = 18;
};

class Sheep :public Animal {};

class Tuo:public Animal {};

class SheepTuo:public Sheep,public Tuo {};

void test01()
{
	SheepTuo st1;

    st1.Age = 18;	//二义性错误, 因为有两个Animal父类
	st1.Sheep::Age = 18;	//加定义域解决问题
}

int main()
{
	test01();
}
```



==**虚继承 :**==

* 使用关键字`virtual` 变为虚继承
* 作用 : 当发生虚基类之后, 这份数据就只有一个了. 可以解决二义性错误.
  * 发生虚基类之后,视为只引用了一份 Animal. 本质为继承下来了 vbptr(虚基类指针), 指向vbtable(虚基类表), 虚基类表里是指向的Animal. 因此实际指向的是Animal.

```c++
class Animal {
public:
	int Age = 18;
};
// 加上关键字virtual 变为徐继成
//Animal类 称为 虚基类
class Sheep :virtual public Animal {};

class Tuo:virtual public Animal {};

class SheepTuo:public Sheep,public Tuo {};

void test01()
{
	SheepTuo st1;

    st1.Age = 18;	//二义性错误, 因为有两个Animal父类
	st1.Sheep::Age = 18;	//加定义域解决问题
}

int main()
{
	test01();
}
```

---

### 4.7 多态

#### 4.7.1 多态的基本概念

* 多态是CPP面向对象的三大特性之一

**多态分为两类**

* 静态多态: 函数重载 和 运算符重载 数据静态多态, 复用函数名.
* 动态多态: 派生类 和 虚函数实现运行时多态.

**静态多态和动态多态区别 :**

* 静态多态的函数地址早绑定 - 编译阶段确定函数地址(地址一开始就是确定的, 也就是运行什么一开始就是固定的)
* 动态多态的函数地址晚绑定 - 运行阶段确定函数地址(地址不能一开始确定, 也就是运行什么运行时再确定(地址反绑定))

Eg1) :

```c++
class Animal
{
public:
	void speak()
	{
		cout << "动物在说话: " << endl;
	}
};

class Cat :public Animal
{
public:
	void speak()
	{
		cout << "小猫在说话" << endl;
	}
};

//执行说话的函数
//运行结果为:动物在说话. 在编译阶段确定函数地址
void doSpeak(Animal &animal)//Animal &animal = cat;父类的引用可以直接接收子类的对象
{
	animal.speak();	//提钱确定了函数地址, 
}

void test01()
{
	Cat cat;
	doSpeak(cat);
}

int main() {
	test01();

	system("pause");
}
```

* 运行结果为动物在说话, 原因为在编译阶段, 引用Animal &animal, 确定了函数地址. 如果想执行让猫说话, 那么这个函数地址就不能提钱绑定, 需要在运行阶段进行绑定.

---

#### 4.7.2 类成员的虚函数 

* 作用: 实现函数的多态性
* 语法: `virtual` 关键字. 

Eg1) :

```c++
class Animal
{
public:
	virtual void speak()	//虚函数
	{
		cout << "动物在说话: " << endl;
	}
};
```

**解释 :**

* 对于有继承子类的类成员来说, 父类的函数地址不能上来就确定函数地址. 由于传入的对象不同, 来执行确定的函数.

**动态多态的满足条件 :**

* 父子级内有继承关系,.
* 子类要重写父类的虚函数.(名称, 返回值类型, 参数列表 相同的成员函数.)
* 子类的成员函数 virtual关键字可写可不写, (由于你引入的父类,所以在执行程序前就决定了优先执行父类成员函数, 但是如果你想根据不同的子类对象运行不同的子类对象里的成员函数, 就需要把父类中的成员函数变为虚函数, 而子类加不加virtual关键字的执行原理相同.)

**动态多态的使用须知 :**

* 在调用同父级 不同子类对象 间相同的函数时, 父类的指针或者引用 必须指向子类的对象

---

#### 4.7.3 多态的深入理解

```c++
class Animal
{
public:
	void speak()	//虚函数
	{
		cout << "动物在说话: " << endl;
	}
};
```

* 此时, 这个类的内存占用为 1.



```c++
class Animal
{
public:
	virtual void speak()	//虚函数
	{
		cout << "动物在说话: " << endl;
	}
};
```

* 加入虚函数后, 类的内存占用变成了 4. 类结构发生改变, 多了一个指针.详细解释:

  * 当你使用虚函数时, 类内多了一个 `vfptr` v代表 virtual; f 代表 function; ptr 代表 pointer; 整体称呼为虚函数(表)指针. 此指针指向虚函数表(`vftable` table 翻译为表的意思), 虚函数指针指向虚函数表, 表的内部记录 虚函数的地址.也就是记录 `&Animal::speak`(成员函数的函数地址, 记录为Animal作用域下的speak, 也就是虚函数的入口地址.)
  * 当子类没有发生重写 且 当子类继承此父类时, 会继承一份的 `vfptr` 指针, 指向子类的虚函数表`vftable`.但此`vftable` 记录着与 父类相同的地址:  `&Animal::speak` 

  ```c++
  class Cat :public Animal
  {
  //没有发生重写
  };
  ```

  * 当子类重写了父类的虚函数时, 子类中的虚函数表 内部 会替换成 子类的虚函数地址.`&cat::speak;` 也就是将函数入口地址替换为了cat的入口地址. 注意: 父类的虚函数表没有发生改变, 改变的只有子类的虚函数表.
  * 当父类的指针或引用指向子类对象的时候, 就会发生多态.  当你使用cat的时候, 就会走cat虚函数表中虚函数的地址.(当你调用接口是, 会去子类寻找对应作用域的函数地址.)

  ---

#### 4.7.4 多态案例 计算机类

  CPP提倡我们使用多态设计程序架构, 因为有点很多.

  * 非多态的变成思路:

  ```c++
  //普通写法
  class Calculator
  {
  public:
  
  	int getResult(string oper)
  	{
  		if (oper == "+")
  		{
  			return Num1 + Num2;
  		}
  		else if(oper == "-")
  		{
  			return Num1 - Num2;
  		}
  		else if (oper == "*")
  		{
  			return Num1 * Num2;
  		}
  
  		//如果想扩展新的功能,需要修改源码
  		//在真实的开发中 提倡 开闭原则: 对扩展开放,对修改关闭.
  	}
  	int Num1;	//操作数1
  	int Num2;	//操作数2
  };
  
  void test01()
  {
  	Calculator c;
  	c.Num1 = 10;
  	c.Num2 = 15;
  
  	cout << c.getResult("*");
  }
  
  int main()
  {
  	test01();
  }
  ```



* 多态写法案例:

```c++
//实现计算器的抽象类, 什么功能都不写
class AbstractCalculator
{
public:

	virtual int getResult()
	{
		return 0;	//仅返回0;
	}
	int Num1;
	int Num2;
};

//实现加法计算器的类
class AddCalculator :public AbstractCalculator
{
	//重写getresult
public:
	int getResult()
	{
		return Num1 + Num2;
	}
};

//减法计算器类
class SubCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return Num1 - Num2;
	}
};

//乘法计算器类
class MulCalculator :public AbstractCalculator
{
public:
	int getResult()
	{
		return Num1 * Num2;
	}
};

void test()
{
	//父类指针或引用 指向子类对象

	AbstractCalculator* abc;	//由于父类指针指向了加法的类, 因此会调用加法的成员函数
	abc = new AddCalculator;

	abc->Num1 = 10;
	abc->Num2 = 15;

	cout << abc->getResult();

	delete abc;//用完后记得销毁
}
```

* 组织结构清晰, 有利于维护
* 可读性强, 可读性是很重要的. 你一眼看懂别人的代码不是你厉害, 是写代码的人强.
* 前期和后期的扩展和维护性高.

---

#### 4.7.5 纯虚函数和抽象类

* 在多态中, 通常父类中虚函数的实现是毫无意义的, 主要都是调用子类重写的内容. 因此可以将虚函数改为==纯虚函数==
* 当类中有了纯虚函数, 这个类也被称为**抽象类**

**语法 :**

* `virtual 返回值类型 函数名 (参数列表) = 0` 

**抽象类的特点 :**

* 无法实例化对象
* 子类必须重写抽象类中的纯虚函数, 否则也属于抽象类.

```c++
class Base
{
public:
	//只要有一个纯虚函数, 这个类就被称为抽象类
	virtual void func() = 0;

};

class Son :public Base
{

};

class Son2 :public Base
{
public:
	void func()
	{
		cout << "Hello";
	}
};
void test01()
{
	Base 01; //错误, 抽象类无法实例化对象.
	Son s1;	//错误,子类没有重写抽象函数
	Son2 s1; //重写之后可以实例化对象.
}
```

---

#### 4.7.6 多态框架思路案例

```c++
//案例一: 冲泡咖啡与茶
class AbstractDrinking
{
public:

	virtual void Boil() = 0;	//注水

	virtual void Brew() = 0;	//冲泡

	virtual void PourInCup() = 0;	//倒入杯中

	virtual void PutSomeThing() = 0;	//加入辅料

	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomeThing();
	}
};

class Coffee:public AbstractDrinking
{
public:
	virtual void Boil()
	{
		cout << "煮农夫山泉" << endl;
	}

	virtual void Brew()
	{
		cout << "冲泡咖啡" << endl;
	}

	virtual void PourInCup()
	{
		cout << "倒入咖啡杯里" << endl;
	}

	virtual void PutSomeThing()
	{
		cout << "倒入糖和牛奶" << endl;
	}

};

class Tea :public AbstractDrinking
{
public:
	virtual void Boil()
	{
		cout << "倒入开水" << endl;
	}

	virtual void Brew()
	{
		cout << "冲泡茶叶" << endl;
	}

	virtual void PourInCup()
	{
		cout << "倒入茶杯里" << endl;
	}

	virtual void PutSomeThing()
	{
		cout << "加入陈皮调味" << endl;
	}
};

void doWork(AbstractDrinking* p)
{
	p->makeDrink();
	delete p;	//释放内存
}

int main()
{
	doWork(new Coffee);
	doWork(new Tea);
}

//电脑组装:将每个零件封装出抽象基类，　并且提供不同的厂商生产的不同的零件，例如intel或Lenvo厂商
//抽象不同零件的类
class CPU
{
public:
	//抽象计算函数
	virtual void calculate() = 0;

};

class VideoCard
{
public:
	//抽象显示函数
	virtual void display() = 0;

};

class Memory
{
public:
	//抽象存储函数
	virtual void storage() = 0;

};

//电脑类
class Computer
{
public:
	Computer(CPU* cpu, VideoCard* vc, Memory* mem)
	{
		mcpu = cpu;
		mvc = vc;
		mmem = mem;		//地址接收
	}

	void work()
	{
		//调用接口
		mcpu->calculate();
		mvc->display();
		mmem->storage();
	}

	~Computer()
	{
		if (mcpu != NULL)
		{
			delete mcpu;
			mcpu = NULL;
		}

		if (mvc != NULL)
		{
			delete mvc;
			mvc = NULL;
		}

		if (mmem != NULL)
		{
			delete mmem;
			mmem = NULL;
		}
	}
private:
	CPU* mcpu;
	VideoCard* mvc;
	Memory* mmem;
};

//具体厂商
class IntelCPU :public CPU
{
public:
	void calculate()
	{
		cout << "CPU of Intel " << endl;
	}
};

class IntelVideoCard :public VideoCard
{
public:
	void display()
	{
		cout << "Intel VideoCard 开始显示了" << endl;
	}
};

class IntelMemory :public Memory
{
public:
	virtual void storage()
	{
		cout << "Intel Memory开始工作" << endl;
	}
};

int main()
{
	//第一台电脑
	CPU* intelcpu = new IntelCPU;
	VideoCard* intelCard = new IntelVideoCard;
	Memory* intelMemory = new IntelMemory;

	Computer* computer = new Computer(intelcpu, intelCard, intelMemory);
	computer->work();
	delete computer;
}
```

#### 4.7.7 虚析构和纯虚析构

* 多态使用时, 如果子类中有属性开辟到堆区, 那么父类指针在释放时无法调用到子类的析构代码

**解决办法 :**

* 将父类的析构函数改为 虚析构 或者 纯虚析构

**虚析构和纯虚析构共性:**

* 可以解决父类指针释放子类对象;
* 都需要有具体的函数实现

**虚析构和纯虚析构区别 :**

* 如果是纯虚析构, 该类属于抽象类, 无法实例化对象.

举例 :

```c++
class Animal
{
public:
	Animal()
	{
		cout << "Animal的构造函数调用" << endl;
	}

	~Animal()
	{
		cout << "Animal的析构函数调用" << endl;
	}
	virtual void speak() = 0;

};

class Cat :public Animal
{
public:
	Cat(string temp)
	{
		cout << "构造函数调用" << endl;
		Name = new string(temp);//堆区创建,应该在析构函数中释放
	}
	void speak()
	{
		cout <<*Name<< "Miao Miao" << endl;
	}
	~Cat()	//释放内存的析构函数
	{
		if (Name != NULL)
		{
			cout << "Cat的析构函数调用" << endl;
			delete Name;
			Name = NULL;
		}
	}
	string* Name;
};

void test01()
{
	Animal *animal = new Cat("Tom");
	animal->speak();

	delete animal;
}
int main()
{
	test01();
}
```

**例子运行结果 :**

* "Animal的构造函数调用"
* "Cat的构造函数调用" 
* Cat Miao Miao //对象行为
*  "Animal的析构函数调用"

**解释 :**

* Cat的析构函数没有调用, 堆区数据没有释放干净.产生原因 是父类指针在析构的时候 不会调用子类中析构函数, 导致子类如果有堆区属性, 会出现内存泄漏.

**解决方法 :**

* 将父类的析构函数改为虚析构函数 
* `virtual ~Animal()` 利用虚析构可以解决 父类指针释放子类对象时不干净的问题

**纯虚析构 :**

* 语法 `virtual ~类名() = 0;` 

* 纯虚析构必须要有 代码实现.

* ```c++
  类名 :: ~类名()		//在类外实现
  {
      函数内容;
  }
  ```

**使用须知 :**

* 在使用多态时, 要想子类对象运行析构函数(非强制 看需求而定, 如果析构函数无实际作用可以跳过析构函数), 需要将父类的析构函数 转变为 虚析构 或 纯虚析构.(子类最后会被释放, 区别在于是否运行子类的虚构函数)
* 纯虚析构 需要声明 也需要 实现.

---

## 5. 文件操作

**意义 :**

* 程序运行时产生的数据都属于临时数据, 程序一旦运行结束都会被释放. 通过文件即可将数据持久化

**使用 :**

* CPP中对文件进行操作需要包含头文件==<fstream>==;

* 文件类型分为两种 :

  * 文本文件 : 文件以文本的ASCLL码形式 储存在计算机中
  * 二进制文件 : 文件以文本的二进制形式存储在计算机中, 一般用户不能直接读懂他们.

* 操作文件的三大类:

  * `ofsteam` :写操作;
  * `ifstream` :读操作;
  * `fstream` : 读写操作;

  ---

### 5.1 文本文件:

#### 5.1.1 写文件

**操作流程 :**

* 包含头文件: `#include<fstream>`
* 创建流对象: `ofsteam ofs;`
* 打开文件: `ofs.open("文件路径",打开方式)`
* 写数据: `ofs<<"写入的数据";` (输出流, 往文件里输出.)
* 关闭文件: `ofs.close();`

**文件打开方式 :**

| 打开方式      | **解释**                   |
| :------------ | -------------------------- |
| `ios::in`     | 为读文件而打开文件         |
| `ios::out`    | 为写文件而打开文件         |
| `ios::ate`    | 初始位置: 文件尾           |
| `ios::app`    | 追加方式写文件             |
| `ios::trunc`  | 如果文件存在先删除, 再创建 |
| `ios::binary` | 二进制方式                 |

**使用须知 :**

* 文件打开方式可以配合使用, 利用操作符
* 用二进制方式写文件`ios::binary | ios::out`

**案例 :**

```c++
//文本文件 写文件
void test01()
{
	//1. 创建流对象
	ofstream ofs;

	//制定打开方式
	ofs.open("test.txt", ios::out);	//如果不指定路径, 则创建在同目录下.

	//写内容
	for (int a = 0; a < 10; a++)
	{
		ofs << "姓名: 张三" << endl;
		ofs << "姓名: 张三" << endl;
	}
	
	//关闭文件
	ofs.close();
}

int main()
{
	test01();
}
```

---

#### 5.1.2 读文件

**步骤 :**

* 包含头文件 `#include<fstream>` 
* 创建流对象 `ifstream ifs`
* 打开文件并判断文件是否打开成功 `ifs.open("文件路径",打开方式);`
* 读数据 四种方式读取(详细看案例)
* 关闭文件 `ifs.close()`

**打开方式 :**

| 打开方式      | **解释**                   |
| :------------ | -------------------------- |
| `ios::in`     | 为读文件而打开文件         |
| `ios::out`    | 为写文件而打开文件         |
| `ios::ate`    | 初始位置: 文件尾           |
| `ios::app`    | 追加方式写文件             |
| `ios::trunc`  | 如果文件存在先删除, 再创建 |
| `ios::binary` | 二进制方式                 |

案例 :

```c++
void test01()
{
	//1. 包含头文件

	//2. 创建流对象
	ifstream ifs;

	//3. 打开文件 并且判断是否打开成功
	ifs.open("test.txt", ios::in);

	if (!ifs.is_open())
	{
		cout << "文件打开失败" << endl;
		return;
	}

	//4. 读数据
	//第一种:
	char buf[1024] = { 0 };
	while (ifs>>buf)	//一行一行读,读到最后返回 fulse
	{
		cout << buf << endl;
	}

	//第二种
	char buf[1024] = {0};
	while (ifs.getline(buf,1024))	//(放到哪个数组或变量, 最多读多少字节)
	{
		cout << buf << endl;
	}

	//第三种
	string buf;
	while (getline(ifs,buf))
	{
		cout << buf << endl;
	}

	//第四种	(文件中所有数据逐字节一个一个的读出来)
	char c;
	while((c = ifs.get()) != EOF) //EOF 为文件尾部标志
	{
		cout << c;
	}
	
	//5. 关闭文件
	ifs.close();
}

int main()
{
	test01();
} 
```

---

### 5.2 二进制文件

* 以二进制的方式对文件进行读写操作, 打开方式要指定为 `ios::binary` 

#### 5.2.1 写文件

* 二进制方式写文件主要利用流对象调用成员函数`write`
* 函数原型 `ostream& write(const char * buffer,int len);` 
* 参数解释: 字符指针buffer指向内存中一段储存空间. `len`是读写的字节数.

**案例 :**

```c++
class Person
{
public:
	char Name[64];
	int Age;
};

void test01()
{
	//1. 包含头文件
	//2. 创建流对象
	ofstream ofs;

	//3. 打开文件
	ofs.open("person.txt", ios::out | ios::binary);

	//4.写文件
	Person p = { "张三", 18 };
	ofs.write((const char*)&p, sizeof(Person));

	//5. 关闭文件5
	ofs.close();
}
```

#### 5.2.2 读文件

* 二进制方式读文件主要利用流对象调用成员函数read
* 函数原型: `istream& read(char *buffer,int len);`
* 函数解释: 字符指针buffer指向内存中一段储存空间. `len`是读写的字节数

案例 :

```c++
class Person
{
public:
	char Name[64];	//姓名
	int Age;	//年龄
};

void test01()
{
	//1. 包含头文件

	//2. 创建流对象
	ifstream ifs;

	//3. 打开文件  判断文件是否打开成功
	ifs.open("person.txt", ios::in | ios::binary);

	if (!ifs.is_open())
	{
		cout << "文件读取失败" << endl;
		return;
	}

	//4. 读文件
	Person p;
	ifs.read((char*)&p, sizeof(Person));

	cout << p.Name << p.Age << endl;

	//5. 关闭文件
	ifs.close();
}

int main()
{
	test01();
}
```

---

# 三. 模板与容器

* 本阶段主要针对CPP泛型编程 和 STL技术做详细讲解, 探讨CPP更深层的使用

> 1) 模板不可以直接使用, 它只是一个框架
> 2) 模板的通用并不是万能的

## 1.1 模板函数:

* CPP另一种编程思想称为 ==泛型编程== ,主要利用的技术就是模板
* CPP提供两种模板机制: 函数模板 和 类模板.

### 1.1.1 函数模板语法

**作用 :**

* 建立一个通用函数, 使函数返回者类型和形参类型可以不具体制定, 用一个虚拟的类型来代表.

**语法**

```c++
template<typename T>
//函数声明或定义
void mySwap(T &a,T &b) { 函数内容 };
```

**使用方法 :**

```c++
//方法一:	自动类型推导
	mySwap(a, b);	//编译器自动推导出数据类型,

	//方法二: 手动指定类型
	mySwap<int>(a, b); //< >中指定的是template<typename T>中的 T 的数据类型
```



**解释 :**

* `template` --- 声明创建模板
* `typename` --- 表面其后面的符号是一种数据类型, 可以用class代替
* T --- 通用的数据类型, 名称可以替换, 通常为大写字母

案例 :

```c++
//函数模板
//实现一个两个整形交换的函数
void swapInt(int& a, int& b)
{
	int temp;
	temp = a;
	a = b;
	b = temp;
}

//交换两个浮点型函数
void swapDoule(double& a, double& b)
{
	int temp = a;
	a = b;
	b = temp;
}

//形式上不同, 逻辑上一样的两个函数.那就使用模板
template<typename T>	//声明一个模板, 高速编译器后面代码紧跟着的T不要报错,T是一个通用的数据类型
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

int main()
{
	int a = 10;
	int b = 20;
	/* (笨方法 - 案例一 :)
	
	swapInt(a, b);
	cout << a;
	*/
	
	/* (笨方法 - 案例二 :)
	double c = 1.1;
	double d = 1.2;
	swapDoule(c, d);
	*/
	
	//利用函数模板进行交换
	//方法一:	自动类型推导
	mySwap(a, b);	//编译器自动推导出数据类型的

	//方法二: 手动指定类型
	mySwap<int>(a, b); //< >中指定的是template<typename T>中的 T 的数据类型

}
```

**总结 :**

* 函数模板利用关键字 template;
* 使用函数模板有两种方式: 自动类型推导, 显示指定类型;
* 模板的目的是为了提高复用性, 将类型参数化;

**注意事项 :**

* 自动类型推导, 必须推导出一致的数据类型T, 才可以使用.

```c++
//函数模板注意事项
template<class T>	//typename 和 class 具有相同意义,无其他区别
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

//1.自动类型推导, 必须推导出一致的数据类型T才可以使用
void test01()
{
	int a = 10;
	char b = 20;	//错误, 数据类型不一致.

	mySwap(a, b);

	cout << a << b << endl;
}
```

* 模板必须要确定出T的数据类型, 才可以使用.

```c++
//函数模板注意事项
template<class T>	//typename 和 class 具有相同意义,无其他区别
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

//1.自动类型推导, 必须推导出一致的数据类型T才可以使用
void test01()
{
	int a = 10;
	char b = 20;	//错误, 数据类型不一致.

	//mySwap(a, b);

	cout << a << b << endl;
}

//2.模板必须要确定出T的数据类型,才可以使用
template<class T>
void func()	//上行声明了函数模板, 因此此行为模板函数
{
	cout << "func调用" << endl;
}
int main()
{
	func();//没有确定函数模板T的数据类型
	func<int>(); //只能使用手动推导类型.
}
```

---

### 1.1.2 案例

```c++
//交换模板
template<class T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

//打印数组模板
template<class T>
void printArray(T& a,int b)
{
	for (int i = 0; a < b; a++)
	{
		cout << a[i] << endl;
	}
}
//排序算法
template<class T>
void mySort(T &a,int len)
{
	for (int i = 0; i < len; i++)
	{
		int max = i;
		for (int j = i + 1; j < len; j++)
		{
			//认定的最大值 比 遍历出的数字 小, 说明j下标元素才是真正的最大值
			if (arr[max < arr[j])
			{
				max = j;
			}
		}
		if (max != i)
		{
			//交换max 和 i下标的元素
			mySwap<arr>(arr[max], arr[i]);
		}
	}
}

void test1()
{
	char charArr[] = { "badcfe" };

	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);

	printArray(charArr, num);

}

int main()
{
	test1();
}
```

---

### 1.1.3 普通函数与函数模板的区别:

* 普通函数调用时可以发生自动类型转换 (隐式类型转换)

* ```c++
  int myAdd01(int a,int b)
  {
  	return a + b;
  }
  void test01()
  {
  	int a = 10;
  	int b = 20;
  	char c = 'c';	//a 对应97, c对应99
  	cout << myAdd01(a, c) << endl;	//编辑器把char 转换为了 int 
  }
  ```

* 函数模板调用时, 如果利用自动类型推导, 不会发生隐式类型转换
* 如果利用现实指定类型的方式, 可以发生隐式类型转换

```c++
//普通函数
int myAdd01(int a,int b)
{
	return a + b;
}


//函数模板
template<class T>
T myAdd02(T a,T b)
{
	return a + b;
}

void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';	//a 对应97, c对应99
	cout << myAdd01(a, c) << endl;	//编辑器把char 转换为了 int 

	cout << myAdd02(a, c) << endl;	//函数模板不能发生隐式转换

	cout << myAdd02<int>(a, c) << endl; //利用现实指定类型的方式,发生隐式类型转换
}
int main()
{
	test01();
}
```

---

### 1.2.5 普通函数与函数模板的调用规则

**调用规则如下 :**

* 如果函数模板和普通函数都可以实现, 优先调用普通函数
* 可以通过空模板参数列表来强调函数模板
* 函数模板也可以发生重载
* 如果函数模板可以产生更好的匹配, 优先调用函数模板

```c++
void myPrint(int a,int b)
{
	cout << "调用普通函数" << endl;
}

template<class T>
void myPrint(T a, T b)
{
	cout << "调用函数模板" << endl;
}

template<class T>
void myPrint(T a, T b,T c)	//函数模板 重载 参数列表参数数量不同
{
	cout << "函数重载调用函数模板" << endl;
}

void test01()
{
	myPrint(1, 1); //在函数和函数模板都可以实现的情况下, 优先调用普通函数.

	myPrint<>(1, 1);	//通过空模板参数列表<>, 可以强制调用函数模板.

	myPrint(1, 1, 1);	//函数模板也可以发生函数重载

	myPrint(1.1, 1.1);	//如果函数模板发生更好的匹配, 优先调用函数模板;
}
int main()
{
	test01();

	system("pause");
}
```

**使用须知 :**

* 函数模板和普通函数最好不要同时出现

---

### 1.2.6 模板的局限性

* 模板不能处理对比自定义数据类型

```c++
class Person	//自定义数据类型
{
public:
	Person(string name, int age)
	{
		this->name = name;
		this->age = age;
	}

	bool operator==(Person& a)	//解决方法1
	{
		if (this->name == a.name && this->age == a.age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	string name;
	int age;
};
//对比两个数据是否相等的函数
template<class T>
bool myCompare(T& a, T& b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}
//利用具体化Person的版本实现代码,具体优先调用(告诉编译器这是专门处理Person对比的方法)
template<> bool myCompare(Person& p1, Person& p2)	//解决方法
{
	if (p1.name == p2.name && p1.age == p2.age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void test01()
{
	int a = 10;
	int b = 20;

	if (myCompare<int>(a, b))
	{
		cout << "a = b" << endl;
	}
	else
	{
		cout << "a != B" << endl;
	}
}

void test02()
{
	Person p1("old li", 21);
	Person p2("old wang", 25);

	if (myCompare(p1, p2))	//错误, 函数模板不能对比自定义数据类型. 解决方法为重载运算符
	{
		cout << "a = b" << endl;
	}
	else
	{
		cout << "a != B" << endl;
	}
}
int main()
{
	test02();

	system("pause");
}
```

**使用须知 :**

* 利用具体化的模板,可以解决自定义类型的通用化
* 学习模板不是为了写模板, 而是在STL能够运用系统提供的模板

---

## 1.2 类模板

### 1.2.1 类模板语法

**作用 :**

* 建立一个通用类, 类中的成员 数据类型可以不具体制定, 用一个虚拟的类型来代表

**语法 :**

```c++
tempalte<typename T>
类
```

**解释 :**

* `template` --- 声明创建模板
* `typename` --- 表面其后面的符号是一种数据类型, 可以用class代替
* T --- 通用的数据类型, 名称可以替换, 通常为大写字母

```c++
template<class NameType,class AgeType>	//创建类模板
class Person
{
public:
	Person(NameType Name, AgeType Age)
	{
		this->Name = Name;
		this->Age = Age;
	}
	void showPerson()
	{
		cout<< this->Name<<", " << this->Age << endl;
	}

	NameType Name;
	AgeType Age;
};

void test01()
{
	Person<string, int> p1("old li", 109);	//<>尖括号里写类的数据类型
	p1.showPerson();
}

int main()
{
	test01();
	system("pause");
}
```

---

### 1.2.2 类模板与函数模板的区别

**主要区别 :**

* 类模板没有自动类型推导的使用方式
* 类模板在模板参数列表中可以有默认参数

```c++
template<class NameType,class AgeType = int>	//模板的参数列表能有默认参数
class Person
{
public:
	Person(NameType Name, AgeType Age)
	{
		this->Name = Name;
		this->Age = Age;
	}

	void showPerson()
	{
		cout << this->Name << ", " << this->Age << endl;
	}

	NameType Name;
	AgeType Age;
};
//类模板没有自动类型推导的使用方式
void test1()
{
	Person p1("old li", 100);	//错误, 无法自动类型推导,必须使用<> 确定数据类型;
	Person<string, int> p1("old li", 100);	//正确
}

```

---

### 1.2.3 类模板中成员函数创建时机

**解释 :**

* 普通类中的成员函数一开始就可以创建(编译器在编译时不会编译类模板成员函数, 在调用时才会创建此成员函数)
* 类模板中的成员函数在调用时才创建

```c++
//类模板中成员函数在调用时才去创建
class Person
{
public:
	void showPerson()
	{
		cout << "Person Show" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 Show" << endl;
	}
};

template<class T>
class myClass
{
public:
	T obj;

	void func1()
	{
		obj.showPerson();
	}
	void func2()
	{
		obj.showPerson2();
	}
};

void test01()
{
	myClass<Person> m;

	m.func1();
	m.func2();	//错误, Person里没有showPerson2();


}
int main()
{
	system("pause");
}
```

---

### 1.2.4 类模板对象做函数参数

- 指定传入类型 ---直接显示对象的数据类型(普通用法)
- 参数模板化 ---传入固定的类, 手动传入类的数据类型
- 整个类模板化 ---直接把类模板化, 可以传入任何的类.

**使用类型函数查看模板数据类型 :**

* `typeid(模板名).name()`  如`cout << typeid(T1).name() << typeid(T2).name() << endl;`

```c++
//类模板对象做函数参数
template<class T1,class T2>
class Person
{
public:
	Person(T1 name, T2 age)
	{
		this->Name = name;
		this->Age = age;
	}

	void showPerson()
	{
		cout << this->Name << ", " << this->Age << endl;
	}

	T1 Name;
	T2 Age;
};
//1. 指定传入类型
void printPerson(Person<string,int>&p)
{
	p.showPerson();
}
//2.参数模板化
template<class T1, class T2>
void printPerson2(Person<T1, T2>& p)
{
	p.showPerson();
	cout << typeid(T1).name() << typeid(T2).name() << endl;
}
//3.整个类都模板化
template<class T>
void printPerson3(T &p)	//整个类均模板化,因此不需要新建具体数据类型模板
{
	p.showPerson();
}
void test01()
{
	Person<string, int>p1("string", 18);
	printPerson(p1);
	printPerson2(p1);
	printPerson3(p1);
}
int main()
{
	test01();
}
	
```

**使用须知 :**

* 使用比较广泛的为 指定传入类型, 也就是普通的函数引用

---

### 1.2.5 类模板与继承

* 当子类继承的父类为类模板, 则需要使用<>确定父类模板的数据类型;如`class son :public Base<string>`

* 子类确定父类模板类型时, 也可以使用模板去代替数据类型.

* ```c++
  template<class T1,class T2>
  class Son2 :public Base<T2>;
  ```

```c++
template<class T>
class Base
{
	T m;
};

class son :public Base<string>	//子类继承父类时,如果不使用<>确定数据类型,则无法分配内存.因此必须使用<>确定数据类型
{
	
};
template<class T1,class T2>
class Son2 :public Base<T2>
{
	T1 obj;
};

void test01()
{
	Son2<int,char> s2;
}
```



**使用须知 :**

* 如果父类时类模板, 子类在继承时需要指定父类中T的数据类型;

---

### 1.2.6 类模板成员函数类外实现

* 在类模板类内声明成员函数, 类外实现成员函数时.要进行两步操作: 声明模板, 声明类模板:

  * ```c++
    //构造函数类外实现
    template<class T1,class T2>	//声明模板
    Person<T1,T2>::Person(T1 name, T2 age);	//声明类模板
    ```

```c++
//类模板成员函数类外实现
template<class T1,class T2>
class Person
{
public:
	Person(T1 name, T2 Age);
	void showPerson();
	
	T1 Name;
	T2 Age;
};

//构造函数类外实现
template<class T1,class T2>	//声明模板
Person<T1, T2>::Person(T1 name, T2 age)	//声明类模板
{
	this->Name = name;
	this->Age = age;
}

//类外成员函数实现
template<class T1,class T2>
void Person<T1, T2>::showPerson()
{
	cout << this->Name << "," << this->Age << endl;
}
```

---

### 1.2.7 类模板分文件编写

* 直接包含.cpp源文件 (不常用, 不建议使用)
* 将声明和实现写到同一个文件中, 并更改后缀名为.hpp, hpp是约定的名称, 并不是强制(属性为头文件)

**使用须知 :**

* 头文件写声明
* 源文件里写实现
* 包含源文件

---

### 1.2.8 类模板与有元

* 全局函数类内实现 - 直接在类内声明有元
* 全局函数类外实现 - 需要提前让编译器指导全局函数的存在
  * 语法 :`friend 函数返回类型 函数名<>(参数列表);`

```c++
//类外实现 //类模板的分文件编写的问题以及解决
template<class T1, class T2>
class Person;

//类外实现	//必须写在前面,让编译器指导函数模板的存在
template<class T1, class T2>
void printPerson2(Person<T1, T2> p)
{
	cout << p.Name << "," << p.Age << endl;
}

template<class T1,class T2>
class Person
{
	friend void printPerson2<>(Person<T1, T2> p);//声明函数模板友元需要告诉编译器函数模板是模板,因此需要加<>
	friend void printPerson1(Person<T1, T2>p)	//全局函数类内实现(很简单,就4行.)
	{
		cout << p.Name << "," << p.Age << endl;
	}


public:
	Person(T1 name, T2 age)
	{
		this->Name = name;
		this->Age = age;
	}

	//通过全局函数打印Person的信息;
private:
	T1 Name;
	T2 Age;
};


void test01()
{
	Person<string, int> p("old li", 18);
	printPerson2(p);
}

int main()
{
	test01();
}
```

---

### 1.2.9 案例

```c++
//实现一个通用的数组类, 要求如下:

```

---

# 四. Standard  Template Library

## 1. STL的基础认知

### 1.1 STL的诞生

* 长久以来, 软件界一直希望建立一种可重复利用的东西
* CPP的面向对象和泛型编程思想, 目的就是复用性的提升
* 大多数情况下,数据结构和算大都未能有一套标准, 导致被迫从事大量重复工作
* 为了建立数据结构和算法的一套标准, 诞生了STL

### 1.2 STL的概念

* STL, 全名(Standard Template Library, 标准模板库);
* STL从广义上分为: container(容器), algorithm(算法), iterator(迭代器);
* 容器和算法之间通过迭代器进行无缝连接;
* STL几乎所有的代码都采用了模板类或者模板函数;

### 1.3 STL的六大组件

* STL大体分为六大组件: 容器, 算法, 迭代器, 仿函数, 适配器(配接器), 空间适配器

1) 容器: 放数据用的. 放各种数据结构,如vector, list, deque, set, map等
2) 算法: 各种常用的算法, 如sort, find, copy, for_eachdeng
3) 迭代器: 扮演了容器与算法之间的胶合剂
4) 仿函数: 行为类似函数, 可作为算法的某种策略
5) 适配器: 用来修饰容器或者仿函数或迭代器接口的东西
6) 空间配置器: 负责空间配置与管理;

### 1.4 容器, 算法, 迭代器

**一. 容器 :**

* 置物之所也, STL容器就是将运用最广泛的一些数据结构实现出来. 常用的数据结构为:数组，链表，树，栈，队列，集合，映射表等．

**容器分为　序列式容器　和    关联式容器    两种**

* 序列式容器: 强调值的排序, 序列式容器中的每个元素均有固定的位置.
* 关联式容器: 二叉树结构, 铬元素之间没有严格的物理上的顺序关系

**二. 算法 :**

* 解决问题的方法
* 有限的步骤, 解决逻辑或数学上的问题, 这一门学科叫做Algorithms(算法)

**算法分为 质变算法 和 非质变算法:**

* 质变算法: 运算过程中会更改区间内元素的内容, 例如拷贝, 替换, 删除等;
* 非质变算法: 是指运算过程中不会更改区间内的元素内容, 例如查找, 技术, 遍历. 寻找极值等;

**三. 迭代器 :**

* 算法需要通过迭代器才能访问到容器里的数据,每个容器都有自己专属的迭代器, 迭代器类似于指针, 初学阶段可以理解为迭代器指针.
* 常用的迭代器为双向迭代器与随机访问迭代器

**迭代器的种类 :**

| 种类           | 功能                                         | 支持运算                      |
| -------------- | -------------------------------------------- | ----------------------------- |
| 输入迭代器     | 只读                                         | ++, ==, !=                    |
| 输出迭代器     | 只写                                         | ++                            |
| 前向迭代器     | 读写, 并能向前推进迭代器                     | ++, ==, !=                    |
| 双向迭代器     | 读写, 并能前后推进迭代器                     | ++, --                        |
| 随机访问迭代器 | 读写, 可以跳跃访问任意数据, 功能最强的迭代器 | ++, --, [n], -n, <, <=, >, >= |

---

### 1.5 容器算法迭代器初识

#### 1.5.1 vector存放内置数据类型

* 容器: `vectpr`
* 算法: `for_each`
* 迭代器: `vector<int>::iterator`

**使用须知 :**

* 使用STL之前需要包含相应的头文件

```c++
#include<vector>
#include<algorithm>//标准算法头文件
void myPrint(int a)
{
	cout << a << endl;
}
//vetcor容器存放内置数据类型
void test01()
{
	vector<int> v;	//创建了一个vector容器, 数组

	v.push_back(10);//push_back() 插入数据;
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	//通过迭代器访问容器中的数据
	vector<int>::iterator itBegin = v.begin();//起始迭代器,指向容器中第一个元素
	vector<int>::iterator itEnd = v.end();//指向容器中最后一个元素的下一个位置

	//第一种遍历方式
	while (itBegin != itEnd)
	{
		cout << *itBegin << endl;
		itBegin++;
	}

	//第二种遍历方式
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << endl;
	}

	//第三种遍历方式 利用STL提供的便利算法
	for_each(v.begin(), v.end(), myPrint);	//回调函数
}
int main()
{
	test01();
}
```

---

#### 1.5.2 Vector存放自定义数据类型

```c++
class Person
{
public:
	Person(string name, int age)
	{
		this->Name = name;
		this->Age = age;
	}

	string Name;
	int Age;
};
//存放自定义数据类型
void test01()
{
	vector<Person>v;

	Person p1("a", 10);
	Person p2("b", 20);
	Person p3("c", 30);
	Person p4("d", 40);
	Person p5("e", 50);

	//向容器中添加数据
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	//遍历容器中的数据
	for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << it->Name << "," << it->Age << endl;	//可以把it理解为指针
	}
}
//存放数据类型的地址
void test02()
{
	vector<Person*>v;

	Person p1("a", 10);
	Person p2("b", 20);
	Person p3("c", 30);
	Person p4("d", 40);
	Person p5("e", 50);

	//向容器中添加数据
	v.push_back(&p1);
	v.push_back(&p2);
	v.push_back(&p3);
	v.push_back(&p4);
	v.push_back(&p5);

	//遍历循环
	for (vector<Person*>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << (*it)->Name << (*it)->Age << endl;
	}
}
```

---

#### 1.5.3 Vector容器嵌套容器

```c++
//Small Vector nest(嵌套) big Vector
void test01()
{
	vector<vector<int>> v;
	//set up small vector
	vector<int>v1;
	vector<int>v2;
	vector<int>v3;
	vector<int>v4;
	
	//Add data to the small vector
	for (int i = 0; i < 4; i++)
	{
		v1.push_back(i + 1);
		v2.push_back(i + 2);
		v3.push_back(i + 3);
		v4.push_back(i + 4);
	}

	//insertion(插入) small Vector to the big Vector
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);
	v.push_back(v4);

	//pass the big Vector, traversal(遍历) all data
	for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++)
	{
		for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++)
		{
			cout << *vit << " ";
		}
		cout << endl;
	}
}
```

---

## 2. STL常用容器

### 2.1 string容器

---

#### 2.1.1 string的基本概念

**1. 本质 :**

* string的本质是CPP风格的字符串, 本质上是一个类

**2. string 和 char *的区别 :**

* char* 是一个指针
* string是一个类, 类内部封装了char*, 管理这个字符串, 是一个char*型的容器.

**3. 特点 :**

* 内部封装了很多的成员方法, 查找find, copy, delete, replace, insert
* string管理char*所分配的内存, 不用担心赋值越界等, 由类内部进行负责

---

#### 2.1.2 string构造函数

* `string();`  //创建一个空字符串 例如 string str;
* `string(const char* s);`	//使用字符串S初始化 (初始赋值)
* `string(const string& str);`    //使用一个string对象初始化另一个string对象
* `string(int n,char c);`    //使用n个字符串对C初始化

```c++
void test01()
{
	string s1;//默认构造
	
	const char* str = "Hello World";
	string s2(str);

	string s3(s2);	//类似拷贝构造函数

	string s4(10, 'a');

	cout << s2 << endl;	//输出Hello World
	cout << s3 << endl; //输出Hello World
	cout << s4 << endl;	//输出10个a
}
```

---

#### 2.1.3 string的赋值操作

**作用 :**

* 给string字符串进行赋值操作

**语法 :**

* `string& operator=(const char* s);`             //char*类型字符串 赋值给当前的字符串
* `string& operator=(const string &s);`         //把字符串s赋给当前的字符串
* `string& operator=(char c);`                          //字符赋值给当前的字符串
* `string& assign(const char *s);`                  //把字符串s赋给当前的字符串
* `string& assign(const char *s, int n);`     //把字符串s的前n个字符赋给当前的字符串
* `string& assign(const string &s);`              //把字符串s赋给当前字符串
* `string& assign(int n, char c);`                  //用n个字符c赋给当前字符串

**解释 :** 

* 可以直接 运算符重载 使用 `+=` 后跟指针,引用和字符串;
* 或者调用`assign`函数, 更能会更全面
* `"字符串"` 这个字符串本身属于 常量指针char

```c++
void test01()
{
	string str1;
	str1 = "hello world";	//隐式转换法 相等于调用构造函数string("Hello World")

	string str2;
	str2 = str1;	//调用拷贝构造函数

	string str3;
	str3 = 'a';	//单个字符赋值

	string str4;
	str4.assign("Hello CPP");	//字符串赋值

	string str5;
	str5.assign("Hello CPP", 5);	//输出Hello Cpp中的前5个字符.

	string str6;
	str6.assign(str5);	//输出str5的数值

	string str7;
	str7.assign(10, 'n');	//前10个 里装的都是c,输出10个c

}
```

**总结 :**

* string的复制方法有很多,`operator=` 这种方式是比较实用的.

---

#### 2.1.4 string字符串的拼接 `+=`  `append`

  **作用 :**

* 实现在字符串末尾拼接字符串

**函数原型 :**

* `string& operator+=(const char* str);`                   //重载+=操作符
* `string& operator+=(const char c);`                         //重载+=操作符
* `string& operator+=(const string& str);`                //重载+=操作符
* `string& append(const char *s); `                               //把字符串s连接到当前字符串结尾
* `string& append(const char *s, int n);`                 //把字符串s的前n个字符连接到当前字符串结尾
* `string& append(const string &s);`                           //同operator+=(const string& str)
* `string& append(const string &s, int pos, int n);`//字符串s中从pos(pos为默认值)开始的n个字符连接到字符串结尾(可以追加部分字符串)

 **解释 :**

* `+=` 后跟 字符串, 指针和引用, 跟`=` 用法一样,不过一个是追加,一个是赋值;
* 或者调用`append` 函数, 功能也一样更全面

```c++
void test01()
{
	string str1 = "我";	//直接使用字符串
	str1 += "爱玩游戏";

	string str2 = ":";
	str1 += str2;	//使用引用

	char str3;
	str3 = 'LOL';
	const char* strP = &str3;

	str1 += strP;	//使用char类型的指针

	cout << str1 << endl;

	string str4;
	str4 = "和";
	str1.append(strP);	//append函数后 charzhizhen

	str1.append("game abcde", 4);	//const char* ,前4个字符放进str1.

	str1.append(str2, 4, 3);
}
```

---

#### 2.1.5 string查找和替换`find` `replace` 

**作用 :**

* 查找: 查找指定字符串是否存在
* 替换: 在指定的位置替换字符串

**函数原型 :**

* `int find(const string& str, int pos = 0) const;`              //查找str第一次出现位置,从pos开始查找
* `int find(const char* s, int pos = 0) const; `                     //查找s第一次出现位置,从pos开始查找
* `int find(const char* s, int pos, int n) const; `               //从pos位置查找s的前n个字符第一次位置
* `int find(const char c, int pos = 0) const; `                       //查找字符c第一次出现位置
* `int rfind(const string& str, int pos = npos) const;`      //查找str最后一次位置,从pos开始查找
* `int rfind(const char* s, int pos = npos) const;`              //查找s最后一次出现位置,从pos开始查找
* `int rfind(const char* s, int pos, int n) const;`              //从pos查找s的前n个字符最后一次位置
* `int rfind(const char c, int pos = 0) const;  `                      //查找字符c最后一次出现位置



* `string& replace(int pos, int n, const string& str); `       //替换从pos开始n个字符为字符串str
* `string& replace(int pos, int n,const char* s); `                 //替换从pos开始的n个字符为字符串s

**解释 :**

* 返回值为整数, 为小字符串的下标; 如果没有子串, 则返回-1;(子串为大字符串里连续的一串字符)
* rfind 与 find的区别为: find 为从左往右查, rfind为从右往左查; 找到的第一个即返回对应元素的下标
* `replace` 字符串为下标开始, 也就是从0开始. 注意,是把原位的字符删掉, 把新的字符重新写进去; 支持string 和 char;

---

#### 3.1.6 string字符串比较 `compare`

**功能描述：**

* 字符串之间的比较

**比较方式：**

* 字符串比较是按字符的ASCII码进行对比, 对比的结果返回int值.

= 返回   0

\> 返回   1 

< 返回  -1

**函数原型：**

* `int compare(const string &s) const; `  //与字符串s比较
* `int compare(const char *s) const;`      //与字符串s比较

**示例：**

```C++
//字符串比较
void test01()
{

	string s1 = "hello";
	string s2 = "aello";

	int ret = s1.compare(s2);

	if (ret == 0) {
		cout << "s1 等于 s2" << endl;
	}
	else if (ret > 0)
	{
		cout << "s1 大于 s2" << endl;
	}
	else
	{
		cout << "s1 小于 s2" << endl;
	}

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大

---

#### 3.1.7 string字符存取 `[int数值]` `at` 

**string中单个字符存取方式有两种**

* `char& operator[](int n); `     //通过[]方式取字符
* `char& at(int n);   `                    //通过at方法获取字符

**访问字符串长度 :**

* `对象名.size();`

**修改单个字符 :**

* `string类对象[下标] = 具体数值;` //对单个字符进行读或写.

**使用须知 :**

* `string类对象.[数值];`, 会输出对应数值下标的元素;
* `string类对象.at(数值)`,会输出对应值下标的元素, 与上方字符串效果一样.
* 必须输入 int 类型

**示例：**

```C++
void test01()
{
	string str = "hello world";

	for (int i = 0; i < str.size(); i++)
	{
		cout << str[i] << " ";
	}
	cout << endl;

	for (int i = 0; i < str.size(); i++)
	{
		cout << str.at(i) << " ";
	}
	cout << endl;


	//字符修改
	str[0] = 'x';
	str.at(1) = 'x';
	cout << str << endl;
	
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at

#### 3.1.8 string插入和删除

**作用 :**

* 对string字符串进行插入和删除字符操作

**函数原型：**

* `string& insert(int pos, const char* s);  `                //插入字符串
* `string& insert(int pos, const string& str); `        //插入字符串
* `string& insert(int pos, int n, char c);`                //在指定位置插入n个字符c
* `string& erase(int pos, int n = npos);`                    //删除从Pos开始的n个字符 

```c++
//字符串插入和删除
void test01()
{
	string str = "hello";
	str.insert(1, "111");
	cout << str << endl;

	str.erase(1, 3);  //从1号位置开始3个字符
    //h111ello
	cout << str << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

注意: 插入和删除的起始下标都是从0开始

#### 3.1.9 string 子串

**功能描述：**

* 从字符串中获取想要的子串

**函数原型：**

* `string substr(int pos = 0, int n = npos) const;`   //返回由pos开始的n个字符组成的字符串

```c++
//子串
void test01()
{

	string str = "abcdefg";
	string subStr = str.substr(1, 3);
	cout << "subStr = " << subStr << endl;

	string email = "hello@sina.com";
	int pos = email.find("@");
	string username = email.substr(0, pos);
	cout << "username: " << username << endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

---

### 2.2 vector容器

**功能 :**

* vector数据结构和数组非常相似, 因此也被称为单端数组

**区别 :**

* 数组是静态的内存空间, 而vector可以**动态扩展**[^解释]

![clip_image002](F:\Desktop\技能\计算机编程语言\编程语言\C++\CPP语言学习\黑马程序员讲义\第5阶段-C++提高编程资料\提高编程能力资料\讲义\assets\clip_image002.jpg)

[^解释]: 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间.

* vector容器的迭代器是支持随机访问的迭代器

#### 2.2.1 vector构造函数

**功能描述：**

* 创建vector容器

**函数原型：**

* `vector<T> v; `               		     //采用模板实现类实现，默认构造函数
* `vector(v.begin(), v.end());   `       //将v[begin(), end())区间中的元素拷贝给本身。
* `vector(n, elem);`                            //构造函数将n个elem拷贝给本身。
* `vector(const vector &vec);`         //拷贝构造函数。

```c++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	vector<int> v1; //无参构造
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	//通过区间方式进行构造
	vector<int> v2(v1.begin(), v1.end());
	printVector(v2);
	//n个elem方式进行构造
	vector<int> v3(10, 100);	//10 个 100
	printVector(v3);
	//拷贝构造 (最常用)
	vector<int> v4(v3);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

---

#### 2.2.2 vector 赋值操作

* `vector& operator=(const vector &vec);`//重载等号操作符
* `assign(beg, end);`       //将[beg, end)区间中的数据拷贝赋值给本身。
* `assign(n, elem);`        //将n个elem拷贝赋值给本身。

```c++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//赋值操作
void test01()
{
	vector<int> v1; //无参构造
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector<int>v2;
    
	v2 = v1; //符号重载的方式赋值, 直接拷贝构造
	printVector(v2);

	vector<int>v3;	//使用其他容器的迭代器赋值
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector<int>v4;	//将n个elem 方式赋值
	v4.assign(10, 100);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}

```

---

#### 2.2.3 vector的容量和大小

**功能描述：**

* 对vector容器的容量和大小操作

**函数原型：**

* `empty(); `                            //判断容器是否为空

* `capacity();`                      //容器的容量

* `size();`                              //返回容器中元素的个数

////重新指定数组长度:

* `resize(int num);`             //重新指定容器的长度为num，若容器变长，则以默认值0填充新位置。

  ​					      //如果容器变短，则末尾超出容器长度的元素被删除。

* `resize(int num, elem);`  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。

  ​				              //如果容器变短，则末尾超出容器长度的元素被删除

```c++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void test01()
{
	vector<int> v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	if (v1.empty())//为真,代表容器为空
	{
		cout << "v1为空" << endl;
	}
	else
	{
		cout << "v1不为空" << endl;
		cout << "v1的容量 = " << v1.capacity() << endl;
		cout << "v1的大小 = " << v1.size() << endl;
	}

	//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
	v1.resize(15,10);
	printVector(v1);

	//resize 重新指定大小 ，若指定的更小，超出部分元素被删除
	v1.resize(5);
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}

```

* 判断是否为空  --- empty
* 返回元素个数  --- size
* 返回容器容量  --- capacity
* 重新指定大小  ---  resize

---

#### 2.2.4 vector的插入和删除

**功能描述：**

* 对vector容器进行插入、删除操作

**函数原型：**

| 函数原型                                         | 解释                                |
| ------------------------------------------------ | ----------------------------------- |
| `push_back(ele);`                                | 尾部插入元素ele                     |
| `pop_back();`                                    | 删除最后一个元素                    |
| `insert(const_iterator pos, ele);`               | 迭代器指向位置pos插入元素ele        |
| `insert(const_iterator pos, int count,ele);`     | 迭代器指向位置pos插入count个元素ele |
| `erase(const_iterator pos);`                     | 删除迭代器指向的元素                |
| erase(const_iterator start, const_iterator end); | 删除迭代器从start到end之间的元素    |
| `clear();`                                       | 删除容器中所有元素                  |

```c++
#include <vector>

void printVector(vector<int>& v) {

	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//插入和删除
void test01()
{
	vector<int> v1;
	//尾插
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);
	printVector(v1);
	//尾删
	v1.pop_back();
	printVector(v1);
	//插入
	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 2, 1000);
	printVector(v1);

	//删除
	v1.erase(v1.begin());//迭代器删除
	printVector(v1);

	//清空
	v1.erase(v1.begin(), v1.end());	//输入两个迭代器
	v1.clear();
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

---

#### 2.2.5 vector数据存取

**功能描述：**

* 对vector中的数据的存取操作
* 操作像string

**函数原型：**

* `at(int idx); `     //返回索引idx所指的数据
* `operator[]; `       //返回索引idx所指的数据
* `front(); `            //返回容器中第一个数据元素
* `back();`              //返回容器中最后一个数据元素

```c++
#include <vector>

void test01()
{
	vector<int>v1;
	for (int i = 0; i < 10; i++)
	{
		v1.push_back(i);
	}

	for (int i = 0; i < v1.size(); i++)
	{
		cout << v1[i] << " ";
	}
	cout << endl;

	for (int i = 0; i < v1.size(); i++)
	{
		cout << v1.at(i) << " ";
	}
	cout << endl;

	cout << "v1的第一个元素为： " << v1.front() << endl;
	cout << "v1的最后一个元素为： " << v1.back() << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

---

#### 2.2.6 vector 容器互换

**基本使用 :**

* 交换两个容器的所有数值, 两个容器的数值相互交换.
* 语法: `被交换的对象 .swap(被交换的对象);` 

**实际用途 :**

* 巧用Swap可以收缩内存空间;
* vector 会自动扩大容量作为预防; 

```c++
void printVector(vector<int>& v)
{
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		std::cout << *it ;
	}
	cout << endl;
}
void test01()
{
	cout << "11" << endl;
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}
	printVector(v);

	vector <int> v2;
	for (int i = 10; i > 0; i--) {
		v2.push_back(i);
	}
	printVector(v2);

	cout << "22" << endl;
	v.swap(v2);
	//两个容器内数值完成交换
}

void test02()
{
	vector<int>v;
	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);

		//容量100000, 大小130000多;

		v.resize(3);
		//容量为3, 大小为130000多; 会造成浪费.

		vector<int>(v).swap(v);
		//容量为3, 大小为3; 避免了内存浪费.

		vector<int>(v);//匿名对象, 输入了类引用, 调用拷贝构造函数; 匿名对象的特鲜, 当前行执行完,系统自动回收.
	}
}
int main()
{
	test01();
}
```

---

#### 2.2.7 vector预留空间

**作用 :**

* 减少vector在动态扩展容量时的扩展次数.
* 如果数据量较大, 可以一开始就预留出来.

**函数原型 :**

* `reserve(int len);` //容器预留`len`个元素长度, 预留位置不初始化, 元素不可访问.

```c++
void test01()
{
	vector<int>v;
	int* p = NULL;
	int num = 0;

	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);

		if (p != &v[0])
		{
			p = &v[0];	//vector的原理为每一次新增变量, 都会开辟一块新的内存
			num++;
		}
	}
	//动态扩展要额外分配
	cout << num;	//10000容量需要开辟30次内存

	v.reserve(1000000); //直接预留相应空间, 所以只需要预留一次;
}
```

---











































---

# 五. 超快猛的C语言极速入门

## 1. 关键字

* C语言语法本身保留单词,不允许用来命名变量,函数,宏等
* C语言 大小写敏感

## 2. 常量与变量

| 类型           | 存储大小 | 值范围                                     |
| -------------- | -------- | ------------------------------------------ |
| char           | 1        | -128 ~ 127 or 0 ~ 255                      |
| unsigned char  | 1        | 0 ~ 255                                    |
| signed char    | 1        | -128 ~ 127                                 |
| int            | 2 or 4   | -32768 ~ 32767 or -2147483648 ~ 2147483647 |
| unsigned int   | 2 or 4   | 0 ~ 65535 or 0 ~ 4294967295                |
| short          | 2        | -32768 ~ 32767                             |
| unsigned short | 2        | 0 ~ 65535                                  |
| long           | 4        | -2147483648 ~ 2147483647                   |
| unsigned long  | 4        | 0 ~ 4294967295                             |
| float          | 4        |                                            |
| double         | 8        |                                            |
| long double    | 16       |                                            |

* 声明变量 :`extern 数据类型 变量名;` ==不同于CPP== 

**常量 :**

* 不分配RAM空间,通常被转换成汇编语言中的立即数.
* 语法 :`3.14(float)` `0L(long)` `0LL(long long)`
* const 修饰变量, 逻辑上是变量,但不可修改(同CPP,会被分配到ROM中)

**其他 :**

* 可以强制类型转换
* `sizeof()` :同CPP

**扩展 :**

* volatile 变量 :变量随时会变化,每次用都要从内存中读取
* static :对全局变量, 是指变量只在本文件代码中有效.

## 3.运算符

* 同CPP

## 4.函数

* 同CPP
* 注意, 需要有程序入口,如`main()`

## 5. 控制流

* 条件: `if - else` `if-else-if` `switch-case`
* 循环: `while` `for` `do-while`
* 提前退出/继续循环: `break` `continue`
* 飞雷神:`goto`

## 6. 数组与指针

* 数组: 连续的内存
* 指针: `*` `&` `++` `--` `->` 等
* 函数指针 : 本质也是地址. 
  * 指针函数 : 主体是函数;函数的需求是返回指针.人话说就是返回指针的函数
  * 函数指针 : 主体是指针;指向函数,函数的内存为1;理解他的重点在于`()`在代码中的优先级更高;
* 完全同CPP

## 7.预处理

**预处理 :**

* 预处理不是真正编译过程的组成部分, 是编译代码之前,一个单独的步骤.
* 由于是编译之前完成的命令, 因此不会使用变量充当判断条件. 因为只有编译之后才有内存
* 作用: **大多是用于处理兼容性问题**

**解释 :**

* 每一个条件编译的指令, 大多与`#endif` 匹配使用; 
* 预处理命令没有`;` 

**语法 :**

* `#` 所有的预处理器命令都是以镜号(#)开头

**常用的预处理指令 :**

| 指令                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `#include`                | 包含一个源代码文件                                           |
| `#define` / `#undef`      | 定义/ 取消一个宏                                             |
| `#ifdef` / `#ifndef`      | 如果宏(没)被定义,返回真(假),并开始一个条件编译块[^解释2]     |
| `#if` / `#else` / `#elif` | 定义一个条件编译块 (`#if` 后面跟条件,条件成立则往后运行;与`#endif`匹配使用[^解释1]) |
| `#endif`                  | 结束一个条件编译块                                           |
| `#error`                  | 输出错误消息,编译会中断 (手动打断预处理编译)                 |
| `#pragma`                 | 可向编译器发布特殊命令, 控制编译(忽略错误,合理避免没必要的提醒.)如`#pragma warning(disable:4996)` 告诉编译器,忽略编译错误 4996 |

```c
#define NUM 1
#if NUM == 1 {print("11111\n")}
#endif		//`#if` 与 `#endif` 必须匹配使用, 作用为结束此代码
```

[^解释1]: 第三行代码 ,`#if` 与 `#endif` 必须匹配使用, 作用为结束此代码块 (使用vs的话,代码没有变灰, 就是可以运行.因为是预编译,所以可以提前看到)

```c
#define NUM 1
#ifdef NUM	//宏NUM是否被定义?如果是,则运行此代码
	printf("%d\n",NUM)
#ifndef NUM //NUM是否被定义?如果是,则运行此代码
#define NUM
#endif	//这个也需要使用endif
        
##undef NUM //宏NUM被取消了, NUM没有了
```

[^解释2]: NUM是否被定义?如果是,则运行此代码;NUM是否被定义?如果是,则运行此代码,注意,需要使用endif(大多用于处理兼容性问题)

**解释 :**

* `#include` 
  * 讲一个文件,嵌入到另一个文件中去
  * 通常用于引入头文件,进而引用另一个C模块
  * 使用须知: 注意配合`#ifndef` 来防止重复引用统一文件

**`#`和`##`的作用 :**

* `#` 作为转换使用

* ```c
  #define to_string(temp) #num//将输入的东西转换为字符串
  #define to__string(temp) #int //将输入的东西转换为整数
  ```

* `##` 作为链接使用

* ```c
  #define createName(index) img##index //将index直接链接在img后面,也就是这个宏每次输出结果,前面都要加"img"
  #define creatName(index) Name##index	//Name(index) 输出为 creatName(参数)
  
  int main()
  {
  	for (int i = 0; i < 10; i++)
  	{
  		int creatName(i) = i;
  		std::cout << Name0 << endl;	输出 0123456789
  	}
  }
  ```

## 8.宏替换与宏函数

**宏替换 :**

* **作用 :** 替换常量 与 代码段 (会在==预处理阶段== ,完成"文本替换". 不消耗运行时间. 预处理器只不过是做了一个文本替换的工作而已)

* ```c
  //宏替换
  #define PI 3.14
  #define M 2+3 // M*2 <=> 2+3*2 <=> 2+6 = 8
  ```

**宏函数 :**

* 作用 使用宏定义函数, 使用三目运算符 

* ```c
  #define MAX(a,b) (a)>(b)?(b):(a) //三目运算符,
  #define test(a,b) ((a)+(b)) //加括号则为一个函数,返回一个值
  #define test(a,b) (a)+(b)	//做替换,并非返回一个值
  ```

* 注意: 使用`()` 来区分代码块, 如果不写括号的话则是单纯的去替换代码段, 

**带语句的宏 :(写多行的宏语句)**

* 换行时, 在行的最后一格写 `\` 连接符

* ```c
  #define ISChar(userKey) if (userKey >= 'A' && userKey <= 'Z') \
  {\
  	printf("他是大写字母")\
  }	//最后一行不用练
  ```

**为了避免宏与自己的代码形成错误解析,多条语句的宏可以do_while(0)包含起来 :**

```c
#define test do{int result = 0;\
printf("%d\n",result);\
}while(0);
```









## 8.其他

1) 结构体/联合体: 初级的针对 "对象" 概念的C语言机制
2) 格式化输入/输出: 是一种应用广泛的解决问题的习惯
   * *格式化, 指数据和字符串的转换方式, c语言用% + 格式
   * *输出: 数据变量=>字符串, *输出: =>数据变量
   * 字符串以隐含的 `\0(null)` 结尾;

1) 标准库: 万物基于C, 更基于标准库.









​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

































