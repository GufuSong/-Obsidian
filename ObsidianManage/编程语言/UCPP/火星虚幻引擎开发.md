
# Unreal Engine 开发基础课程

## Ⅰ. 虚幻高级程序基础

### 1.1 工程目录结构与调试基础 

#### 一. UE CPP 与 工程目录  :

**1. UE CPP 与 普通 CPP 的区别 :**

- 普通CPP无法进行内存管理 ,  如关键字`new`则是在内存中开辟堆区内存 , 在不需要使用此空间时则应该`delete`内存空间 .  
- 虚幻CPP 则可以自动管理内存 . 

**2. CPP工程目录结构 :**

- `.vs`:  本地的VS配置 ,  智能提示等等 .  放置配置文件 ,  缓存文件等 .  每个主机分别有一套`.vs`工作环境 .  不可删/无需打包 .
- `Binaries`:  编译文件 ,  生成`.dll`文件 ,  所有的蓝图 ,  cpp等 ,  最后都会打包为`.dll`文件 .  `.pdb`为调试链接文件 .  此文件夹可再生成 .
- `Config`:  引擎本地配置信息 .  不可删 .
- `Content` :  资产文件夹 .  不可生成 .
- `Intermediate`:  中间文件 ,  存放所有代码的过渡代码 ,  可再生成 ,  可删 .
- `Saved` :  游戏日志 ,  游戏本地配置 ,  游戏自动保存( Autosaves ) 等 .  生成文件 ,  在确定无用时可删 .
- `Source` :  源文件 .  不可删
- `.sln`:  入口文件 ,  可再生成 .
- `.uproject`:  入口文件, 删了项目作废 .
- `.db`:  缓存文件 .

>在拷贝项目时 ,  `Config` , `Content` , `Source` , `.uproject` 为重要文件 ,  其他文件可自动生成 .


#### 二. 调试与断点 :

**1. 非调试模式启动 :**

- `Ctrl + F5`:  直接唤醒虚幻引擎 .  

**2. 调试模式启动 :**

- `F5`:  准许在VS中监视引擎启动 .

**3. 断点与调试 :**

- 点击左侧面板的菜单栏可以增加断点 ,  用于在调试模式下排查调试问题 .

#### 三. 常见的错误 :

**1. 分别编译错误 :**

- CPP项目出现红色下划波浪线 ,  错误原因为程序环境无法找到头文件信息 .
- 由于CPP编译的四个步骤 :  预处理 - 编译 - 汇编 - 链接 ,  在链接阶段 ,  程序准许重复声明(程序带花括号) ,  但禁止重复定义 .
- 解决办法 :  
	- 重新生成`.sln`文件 .
	- 右键 `项目名称` 属性 ,  观察VC++目录 ,  可能是注册表路径错误 .  并且此问题不会干扰编译 .  点击右侧三角重新手动配置即可解决报错 .

**2. 启动目标平台问题 :**

- 启动目标平台一定要指定 Win64 .

#### 四. `override`关键字 :

**1. 作用 :**

- 在重写父类的虚函数时 ,  可能写错函数名 .  但是如果不写`override`关键字时 ,  编译器无法帮你检查父类中是否含有此关键字 ,  会认为这是你在子类中新加的虚函数 .  此关键字可以避免重写父类虚函数时报错 .


#### 五. 安装调试用符号

**1. 调试符的作用 :**

- 可以参加调试引擎 ,  用来知道引擎实现的方式 .  



### 1.2 UBT 与 UHT 详解

#### 一. 虚幻引擎的结构

**1. 虚幻引擎的整体结构 :**

- 1. 硬件层的对接 .
- 2. 中间层 ,  链路 管理工具等
-  3. 产品层 .


**2. UBT - Unreal Build Tool :**

- UBT 是一个自定义工具 ,  用于管理跨各种构建**配置构建**虚幻引擎4 ( UE4 ) 源代码过程 ,  此工具附加在引擎之外 ,  管理模块与模块之间的关系 .  
- UE4有很多模块 ,  每个模块都有一个`build.cs`控制其构建方式的文件 .
- 优势为更灵活的配置工程特性 ,  如配置AI行为的模块 ,  只需要引入AI模块即可 .  


**3. UHT - Unreal Header Tool :**

- UHT 是一个支持`UObject`系统的自定义解析和代码生成工具 .
- 专门用于做头文件的关系梳理 .  能够根据引擎的特殊标记 ( 紫色的标记宏 )  标记的不同特性给UHT使用 .  UHT 会根据这些宏生成自定义的代码以实现各种与`UObject`的功能 .  ( 当你按 F7 后 ,  UBT就开始工作了 ,  UHT会帮助你生成中间文件 ,  再进行编译 ,  比如`.generated.h`文件即是UHT帮助你生成的中间文件 .) 
- UHT的目的是为了帮助虚幻做到反射机制 ,  与蓝图通信等 .


### 1.3 项目目录结构

#### 一. visual Studio 的操作单位 :

**1. 解决方案 :**

- 每个解决方案可以看作为一个操作单位 .  解决方案里有不同区域的项目 .

**2. 源码文件与自定义文件 :**

- 源码文件对比自定义文件在标签页多出一把锁头 .  



#### 二. 项目目录结构 :

**1. 引用 :**
- 查询当前项目引用了哪些库 .  

**2. 外部依赖项 :**
- 我们的工程项目依赖引擎项目里的资产内容 .

**3. Config :**
- 配置文件 .

**4. Source :**
- `项目名`:  虚幻引擎默认把你创建的项目认为是一个模块 ,  这个模块的名字就是项目的名字 .

**三. 项目`Source`文件 :**

- `项目名(仅本文件夹内文件可编辑) :`
	- `Build.cs`:  `Cshape`文件 ,  UBT与UHT均是`Cshape` .  此文件作用与UBT .
	- `项目名.cpp/.h`:  注入模块 .  将自己写的模块装载/挂载至引擎中 .
	- `项目名GameModeBase.cpp`:  赠送的 ,  无用途 .
- `项目名.Target.cs / 项目名Editor.Target.cs`:  给编辑器使用 ,  告知编辑器引用了本模块 .  令本模块可以运行在编辑器中 .
- `项目名.uproject`:  启动名称 ,  包含版本等信息 .

>模块就类似军队的不同兵种 ,  好处为轻量化的更专精的运行 .


### 1.4 编译类型与编译状态

#### 一. 编译器运行状态 :

**1. Shipping 发行 :**

- 无控制台命令 ,  统计数据和性能分析 .  无额外性能开销 ,  可以直接满状态运行产品 .

**2. Development 开发 :**

- 允许编辑器发射查看代码更改 .

**3. DebugGame 调试游戏 :**

- 调试游戏代码 .

**4. `Debug` 调试 :**

- 必须在编辑器上加 `-debug` 参数才能反射查看代码更改 .


#### 二. 命名规则 :

**1. 虚幻引擎CPP命名规则 :**

- 模板类以T作为前缀 ,  如TArray等 .
- UObject派生类均为U前缀 .
- AActor派生类均以A为前缀 .
- `SWidget` slate类型派生类都以S为前缀 . Slate就是虚幻UI的实现框架 .
- 全局对象使用G开头 ,  如`GEngine` .  引擎实例指针 ,  为全局变量 .
- 抽象接口以I 前缀.
- 枚举 E 开头. 有穷序列的集合 .
- bool 变量均为 b 开头.
- 其他大部分或自定义数据类型为 F 开头, 如FString , FName .
- typedef 的以原型名前缀为准 . 虚幻中如果以F开头的语法要么是自定义数据, 要么是别称类型 .
```c++
//typedef 用于给负责变量起简化名称

typedef unsigned int uint;    // 将unsigned int 简化为 uint;
```
>虚幻引擎遵守帕斯卡命名法则 .  (每个单词的首字母均大写 .)

- 在编辑器和C#里, 类型名是去掉前缀过的 .
- UHT在工作的时候需要你提供正确的前缀 ,  你必须要遵守 .  


**二. 资源明明规则 :**

- Level/Map → `L_`
- Blueprint → `BP_`
- Widget Blueprint → `WBP_`
- Material → `M_`
- Static Mesh → `SM_`
- Skeletal Mesh → `SK_`
- Texture → `T_`
- Particle System → `PS_`

#### 1.5 面向对象七大原则

**一. 单一职责原则 :**
- 设计本质出发，一个类尽量专注处理一件事情，或是一类事情（管理器）
- 函数也应该只处理一件事情 .

**二. 里氏转换原则 :**
- 多态, 父类存虚函数, 子类重写他 .  将子类的指针存放在父类的指针中 ,  这个过程就叫里氏转换 .
- 当两个类存在继承关系时，子类可以替代父类（可以使用父类类型指针的地址，但是你无法使用子类指针存储父类指针的值）
- 任何基类出现的地方，子类出现是没有问题; 
- 速记法：父亲可以抱起儿子，儿子无法抱起父

**三. 依赖倒置原则 :**
- 高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块

>例妆我们锻造首饰，那么锻造中我们可能会生产黄金，白银，青铜等手镯。我们编写一个锻造递数，通过外部传参，告知我生产类型。参数可能是原子参数(枚举)。那么当诉求发生变化时，例如函数内需要知道金属的密度，来更改锻造方法，那么方法就无法解决此问题（原因是单从参数枚举无法获知金属密度值），这时我们可！象一个金属类，类内部构建一个虚函数，用来获取密度。传递参数从枚举修改为金属类. 那么函数内就只需要依赖抽象接口函数了，不依赖细节值。

**四. 迪米特原则 :**
- 量少的去了解其他与你无关的内容 .
- 低类之间的耦合（低耦合高内聚）.

**五. 接口隔离原则 :**
- 客户端不应该依赖它不需要的接口 .  一个类对另一个类的依赖应该建立在最小(不是最少, 是最细) 的接口上 
- 使用多个专门的接口比使用单一的总接口好 ,  不要把所有的接口都声明在一起 .

**六. 开闭原则 :**
- 对需求扩展开放 ,  对修改封闭 .
- 不要改已经写好的功能 ,  当新需求产生啥应该降低对旧功能的修改, 以规避旧有逻辑的连锁反应 .

**七. 组合/ 聚合复用原则 :**
- 组合设计方案优于继承设计方案 .  继承层级越深, 子类行为, 属性越臃肿 .  
- 组合方式可以大大提升逻辑功能的复用, 并且更加灵活 .
- 缺点:  设计内容耦合 .
- 组件设计就是典型的组合设计原则 .

>程序设计没有绝对的对与错 ,  效率与结果才是验证结果的依据 .

### $.5 快速引入头文件

**一. 寻找相对路径 :**

**1. 手动寻找需要引用的文件相对路径 :**
- 输入需要使用的类名 ,  快捷操作转到声明 .
- 悬停鼠标至菜单栏 ,  class 之前的路径引擎均存储为相对路径 .

**2. 使用VA获取头文件 :**
- 右键需要使用的类名, 快捷操作`Add Unclude` .
- 也可以点击类成员函数 ,  也可以快速操作 .



## Ⅱ. 虚幻开发程序基础

### $.1 Actor 类基础

>`UObject` 是塑造Actor的根 .  由Actor 进行构建 ,  Component 进行行为组件 ,  完成整个游戏世界的元素展示 .


**一. 创建Actor :**

**1. 静态创建 :**
- 创建Actor后直接拖拽进场景 .

**2. 动态创建 :**
- 在游戏运行中动态生成Actor .  C++的类与BP的类生成规则相同 ,  可以直接在BP中生成CPP类 .

>在编辑器启动时, 游戏已经启动了 .  这是UE的特性 .  区别在于普通蓝图的每帧运行没有被调用 .
>在创建蓝图时, 并非直接从Actor 中继承 ,  而是UBlurprintActorBase ,  这是蓝图特定的Actor类, 自带一个根组件 ,  为蓝图提供Transform .

**二. 蓝图类引用规则 :**

**1. Object Reference /  Class Reference  :**
- 硬引用 .  内存被引用时不会被释放 .

**2. Soft Object Reference
- 软引用 ,  对于虚幻的内存管理 ,  当内存被占用时不会影响内存被释放 . 
- 出现互相引用时 ,  变量能被强制释放 .

**三. Actor 默认类构成 :**

**1. 构造函数 :**
- 禁止随意增加参数 ,  只能自己去额外写接口 .  所有 UObject（包括 AActor）实例都是通过引擎内部机制（如 `SpawnActor`、`NewObject`）创建的，调用的是默认构造函数，且只接受一个 `FObjectInitializer&` 参数。它不会传递你定义的额外参数
- 即使你自己定义了带额外参数的构造函数，也会被引擎忽略，Actor 始终由默认构造器初始化 。

**2. `BeginPlay()` :**
- 开始游戏时调用逻辑 .

**3. `Tick(float DeltaTime)`:
- 每帧运行 .

>须知, 禁止在Actor内部生成自己 ,  会导致栈溢出 .


**四. Actor 创建后运行流程 :**
- 构造函数调用 .

- 初始化成员变量 .

- 如有蓝图 ,  则初始化蓝图数据 .

- 构建组件 .
	- 并不是将组件New出来 ,  而是初始化组件的一些属性 ,  一些关系 .

- Begin Play (标志Actor 被创建到世界当中 .)

- Tick .

### $.2 Actor 类成员函数

#### `GetWorld()`获取指向当前Actor所处的UWorld实例的指针.
>直接

#### `Destroy()`强制消亡自身 .
>调用自身Destroy函数 执行强制消亡指令 .

**一. 参数说明 :**
**1. `bNetForce`**
- 是否强制网络同步删除 ?

**2. `bShouldModifyLevel`**
- true: 先修改关卡, 再删除Actor .
- flast: 先删除Actor ,  再删除关卡 .

#### `SetLifeSpan`延时删除

### $.3 UWorld工厂函数

>蓝图中也有工厂函数 .  在名称下面是否具有 '目标是xxx' 字段 ,  如有 ,  则为普通的成员函数 ,  如没有 ,  则为工厂函数 .  在CPP中 ,  添加Actor 一般使用 `UWorld` 类.

**一. `UWorld`基础 :**

**1. 什么是`UWorld`
- `UWorld` 是引擎中表示整个“世界”（地图＋运行状态）的核心对象，用于管理当前场景中所有活动元素，包括 Actors、Components、GameMode、GameState，以及关卡等组成部分 . 
- 无法直接声明UWorld实例 ,  引擎会生成多套UWorld ,  需要Actor成员函数返回指针调用 .
- [UWorld | Unreal Engine 5.6 Documentation | Epic Developer Community](https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Engine/UWorld?utm_source=chatgpt.com) 即可查看UWorld官方文档 ,  如果图标为f+绿色小方块则代表 非静态成员变量 .

---
#### `SpawnActor`生成Actor
>`UWorld::SpawnActor()` ,会在当前场景中真正生成一个新的 Actor 实例 ,  并返回被生成实例的指针 .

**一. 使用方法 :**

**1. 语法 :**
```c++
GetWorld->SpawnActor</*输入生成的Actor*/>(/*七个重载函数,也可以为空*/);
```













### $.4 `GameMode`类基础


### $.5 `Super`关键字
>注意, 在虚幻引擎中 ,  只要重写父类的虚函数 ,  则必须显示调用父类同名函数 .  原因如下:
>
>  - 父类中的虚函数往往包含对引擎核心行为的调用，例如 `BeginPlay()` 中设置组件初始化、`Tick()` 中处理延迟动作、检查销毁条件等。若你重写而不调用 `Super::`，这些引擎逻辑将不会执行，可能导致组件不生效、事件不触发或生命周期异常 .
>  
>  - 蓝图中重写事件，如 `BeginPlay`，也需加“Add Call to Parent Function”节点来确保父类逻辑执行

**一. 虚幻引擎变成规则 :**

**1. 原因规则 :**
- 注意, 在虚幻引擎中 ,  只要重写父类的虚函数 ,  则必须显示调用父类同名函数 .  
- 父类中的虚函数往往包含对引擎核心行为的调用，例如 `BeginPlay()` 中设置组件初始化、`Tick()` 中处理延迟动作、检查销毁条件等。若你重写而不调用 `Super::`，这些引擎逻辑将不会执行，可能导致组件不生效、事件不触发或生命周期异常 .

**2. 解决办法 :**
- 你仍然可以在执行重写函数之前或之后执行父类的函数逻辑 ,  确保程序正常运行 .
- 蓝图中重写事件，如 `BeginPlay`，也需加“Add Call to Parent Function”节点来确保父类逻辑执行 .

**二. `Super`关键字使用作用 :**

**1. 作用 :**
- Super 本质是宏 ,  也就是当前派生类的父类的别名 .
- 用于解决调用父类逻辑的问题 .

**2. 使用须知 :**
- 如果采用多继承 ,  则Super 只会指向第一继承父类 .

### $.6 `UClass`类型基础

>在CPP的编程中 ,  无法直接使用类作为参数 .  所有的类在编译阶段均会被拆散 ,  仅保留作用域 .  为了解决这个问题 ,  虚幻引擎会在编译阶段为类生成快照

**一. 什么是UClass ?**

**1. 原理 :**
- UClass 用来**描述类的结构信息**，支持：运行时获取类名/父类/所有属性/所有函数 ,  动态创建对象（SpawnActor/ConstructObject 等）,  支持序列化、网络同步、蓝图、GC等 .

**2. 作用 :**
- `UClass` 本质为虚幻中特定的用于描述类的数据类型 ,  继承自UObject 
- 设计目的为帮助开发者将类作为参数进行传递 ,  但传递的不是真正的类 ,  而是传递类的资产模板 .  也就是UClass 仅能存储类模板, 不能直接存储类 .
- 只有U类有传递资产模板的功能 ,  每一个U类都有一个函数为`StaticClass` ,  可以获取当前类的资产模板 .

**二. 获取类模板 :**

**1. 限制 :**
- 只有U类才有`StaticClass()`函数 ,  返回UClass 变量 ,  也就是类模板 .

### $.7 宏指令

#### `UFUNCTION(Exec)`
>指令标记 ,  在声明函数时粘贴至上一行 ,  在BeginPlay后可以在引擎内通过`~`控制台直接调用函数 .
>此功能只有在场景内存在实例时才能调用 .










